(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{485:function(t,s,a){"use strict";a.r(s);var e=a(2),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-node-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-node-简介"}},[t._v("#")]),t._v(" 1. Node 简介")]),t._v(" "),a("h3",{attrs:{id:"_1-异步-i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-异步-i-o"}},[t._v("#")]),t._v(" 1.异步 I/O")]),t._v(" "),a("h3",{attrs:{id:"_2-事件与回掉函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-事件与回掉函数"}},[t._v("#")]),t._v(" 2.事件与回掉函数")]),t._v(" "),a("h3",{attrs:{id:"_3-单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-单线程"}},[t._v("#")]),t._v(" 3.单线程")]),t._v(" "),a("p",[t._v("单线程的缺点：")]),t._v(" "),a("ul",[a("li",[t._v("无法利用多核处理器")]),t._v(" "),a("li",[t._v("错误会引起整个应用退出，应用的健壮性值得考验")]),t._v(" "),a("li",[t._v("大量计算占用 cpu 导致无法继续调用异步 I/O")])]),t._v(" "),a("h3",{attrs:{id:"_4-跨平台"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-跨平台"}},[t._v("#")]),t._v(" 4.跨平台")]),t._v(" "),a("ul",[a("li",[t._v("操作系统与 Node 上层模块系统之间构建了一层平台层架构，即 libuv")]),t._v(" "),a("li",[t._v("混合应用")])]),t._v(" "),a("h3",{attrs:{id:"_5-低资源占用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-低资源占用"}},[t._v("#")]),t._v(" 5.低资源占用")]),t._v(" "),a("ul",[a("li",[t._v("适合做云平台开发")])]),t._v(" "),a("h3",{attrs:{id:"_6-前端赋能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-前端赋能"}},[t._v("#")]),t._v(" 6.前端赋能")]),t._v(" "),a("ul",[a("li",[t._v("serverless")]),t._v(" "),a("li",[t._v("工具编写")]),t._v(" "),a("li",[t._v("桌面图形界面应用程序")])]),t._v(" "),a("h3",{attrs:{id:"_1-5-node-应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-node-应用场景"}},[t._v("#")]),t._v(" 1.5 Node 应用场景")]),t._v(" "),a("ol",[a("li",[t._v("I/O 密集型适合 IO 密集型，是因为 js 天生的异步写法，并不是比其他语言优秀，也因为 node 刚出的时候 java 对异步支持不是很好。")]),t._v(" "),a("li",[t._v("不擅长 CPU 密集型")]),t._v(" "),a("li",[t._v("与一流系统和平共处")]),t._v(" "),a("li",[t._v("分布式应用")])]),t._v(" "),a("h2",{attrs:{id:"_2-模块机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-模块机制"}},[t._v("#")]),t._v(" 2. 模块机制")]),t._v(" "),a("p",[t._v("在 Node 中引入模块，需要经历如下 3 个步骤：")]),t._v(" "),a("ol",[a("li",[t._v("路径分析")]),t._v(" "),a("li",[t._v("文件定位")]),t._v(" "),a("li",[t._v("编译执行")])]),t._v(" "),a("p",[t._v("在 node 中，模块分为两类：")]),t._v(" "),a("ol",[a("li",[t._v("核心模块：node 提供的模块。核心模块部分在 node 源代码的编译过程中，编译进了二进制执行文件。在 node 进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中有限判断，所以它的加载速度时最快的。")]),t._v(" "),a("li",[t._v("文件模块：用户编写的模块。文件模块时在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。还有一种特殊的文件模版叫做"),a("code",[t._v("自定义模块")]),t._v("，这类模块的查找是最费时的，因为它是沿路径逐级递归查找 node_modules 目录")])]),t._v(" "),a("h3",{attrs:{id:"_2-2-node-的模块实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-node-的模块实现"}},[t._v("#")]),t._v(" 2.2 Node 的模块实现")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("优先从缓存加载 Node 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同与浏览器的是，Node 缓存的是编译和执行之后的对象。")])]),t._v(" "),a("li",[a("p",[t._v("路径分析")]),t._v(" "),a("blockquote",[a("p",[t._v("require()方法接受一个标识符作为参数")])])])]),t._v(" "),a("p",[t._v("1.1 模块标识符分类")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("核心模块，如"),a("code",[t._v("http、fs、path")])])]),t._v(" "),a("li",[a("p",[t._v(".或..开始的相对路径文件模块")])]),t._v(" "),a("li",[a("p",[t._v("以/开始的绝对路径文件模块")])]),t._v(" "),a("li",[a("p",[t._v("非路径形式的文件模块，也就是"),a("code",[t._v("自定义模块")])]),t._v(" "),a("p",[t._v("1.2 文件定位")])]),t._v(" "),a("li",[a("p",[t._v("文件扩展名分析")]),t._v(" "),a("ul",[a("li",[t._v("如果没有提供扩展名，则按照"),a("code",[t._v(".js、.json、.node")]),t._v("补足扩展名，依次尝试")])])]),t._v(" "),a("li",[a("p",[t._v("目录分析和包 - 在 require 分析文件扩展名之后，可能没有找到对应文件，但是得到了一个目录，这在引入自定义模块和逐个模块路径进行查找时会出现，此时 node 会将目录当作一个包来处理 - 然后 node 对当前目录的 package.json 文件进行"),a("code",[t._v("JSON.parse()")]),t._v("解析，取出"),a("code",[t._v("main")]),t._v("的值对文件进行定位，如果缺少扩展名，则进入扩展名分析步骤 - 如果"),a("code",[t._v("main")]),t._v("属性指定的文件名错误，或者没有"),a("code",[t._v("package.json")]),t._v("文件，"),a("code",[t._v("node")]),t._v("会将"),a("code",[t._v("index")]),t._v("当作默认文件名,然后依次查找"),a("code",[t._v("index.js、index.json、index.node")]),t._v(" - 如果目录分析过程没有找到任何文件，则进入下一个模块路径进行查找。如果模块路径数组都没有查到，则抛出失败的异常。 1.3 模块编译"),a("br"),t._v("\n在 node 中，每个文件模块都是一个对象，它的定义如下：")])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Module")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" parent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("parent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" parent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("parent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" parent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("children"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    parent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("children"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("filename "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("loaded "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("children "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node 会新建一个模块对象，然后根据路径载入并编译。不同的扩展名，编译方式不同：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v(".js")]),t._v("，通过"),a("code",[t._v("fs")]),t._v("模块同步读取文件后编译执行。")]),t._v(" "),a("li",[a("code",[t._v(".node")]),t._v("，这是用"),a("code",[t._v("c/c++")]),t._v("编写的扩展文件，通过"),a("code",[t._v("dlopen()")]),t._v("方法加载最后编译生成的文件。")]),t._v(" "),a("li",[a("code",[t._v(".json")]),t._v("，通过"),a("code",[t._v("fs")]),t._v("模块同步读取后，用"),a("code",[t._v("JSON.parse()")]),t._v("解析返回结果.")]),t._v(" "),a("li",[t._v("其他格式文件，都按照"),a("code",[t._v(".js")]),t._v("文件载入。")])]),t._v(" "),a("p",[t._v("每一个编译成功的模块都会将其文件路径作为索引缓存在"),a("code",[t._v("require.cache")]),t._v("对象上，以提高二次引入的性能")]),t._v(" "),a("p",[t._v("如果想对其他格式文件加载，可以通过扩展"),a("code",[t._v("require.extensions['.ext']")]),t._v("的方式实现。")]),t._v(" "),a("p",[t._v("但是从"),a("code",[t._v("v0.10.6")]),t._v("开始,官方不鼓励通过这种方式来进行加载，而是希望先将其他语言转换成 js 文件再加载，这样做的好处在于不将繁琐的编译加载等过程引入 Node 的执行过程中")]),t._v(" "),a("ol",[a("li",[t._v("JS 模块的编译在"),a("code",[t._v("commonjs")]),t._v("规范中，我们知道每个模块存在"),a("code",[t._v("require、exports、module")]),t._v("三个变量，但是在模块文件中并没有被定义，为了防止污染全局变量，在编译的过程中，node 对获取的 js 文件内容进行了头尾包装，头部添加"),a("code",[t._v("(function (exports, require, module, __filename, __dirname) {\\n")]),t._v(",尾部添加了"),a("code",[t._v("\\n});")]),t._v(",一个正常的 js 文件会被包装成如下的样子：")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("exports"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" require"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" __filename"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" __dirname")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" math "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"math"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  exports"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("area")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("radius")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Math"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PI")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" radius "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" radius"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这样每个模块之间都进行了作用域隔离。包装之后的代码会被 vm 原声模块的"),a("code",[t._v("runInThisContext()")]),t._v("方法执行，返回一个具体的"),a("code",[t._v("function")]),t._v("对象，最后，将当前模块对象的"),a("code",[t._v("exports")]),t._v("属性、"),a("code",[t._v("require")]),t._v("方法、"),a("code",[t._v("module（模块对象自身）")]),t._v(",以及在文件定位中得到的完整路径和文件目录作为参数传递给这个"),a("code",[t._v("function()")]),t._v("执行。 1.1 exports 和 module.exports"),a("br"),t._v("\n因为 exports 是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值，比如：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("change")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 100")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("change")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 10")]),t._v("\n")])])]),a("p",[t._v("如果要达到 require 引入一个类的效果，请赋值给 module.exports 对象。这个迂回的方案不改变形参的引用。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("C/C++模块的编译 .node 的模块不需要编译，只有加载和执行的过程，在执行的过程中，模块的 exports 对象与.node 模块产生联系，然后返回给调用者。")]),t._v(" "),a("li",[t._v("JSON 的文件的编译 node 利用 fs 模块读取 json 文件的内容之后，调用 JSON.parse 方法得到对象，然后将它赋给模块对象"),a("code",[t._v("exports")]),t._v("，以供外部使用")])]),t._v(" "),a("h3",{attrs:{id:"_2-3-核心模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-核心模块"}},[t._v("#")]),t._v(" 2.3 核心模块")]),t._v(" "),a("p",[t._v("核心模块分为 c/c++和 js 编写的两部分，c/c++文件存放在 Node 项目下的 src 目录，javascript 文件存放在 lib 目录下。")]),t._v(" "),a("ol",[a("li",[t._v("js 核心模块的编译过程"),a("br"),t._v("\n在编译所有 C/C++文件之前，编译程序需要将所有的 js 模块文件编译为 C/C++代码。 1. 转存为 C/C++代码 Node 采用了 V8 附带的 js2c.py 工具，将所有内置的 js 代码（src/node.js 和 lib/*.js）转换成 C++里的数组，生成 C++里的数组，生成 node_natives.h 头文件:")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('namespace node {\nconst char node_native[] = { 47, 47, ..};\nconst char dgram_native[] = { 47, 47, ..};\nconst char console_native[] = { 47, 47, ..}; const char buffer_native[] = { 47, 47, ..}; const char querystring_native[] = { 47, 47, ..}; const char punycode_native[] = { 47, 42, ..};\n...\nstruct _native { const char* name; const char* source; size_t source_len;\n};\nstatic const struct _native natives[] = {\n{ "node", node_native, sizeof(node_native)-1 },\n{ "dgram", dgram_native, sizeof(dgram_native)-1 }, ...\n};\n     }\n')])])]),a("p",[t._v("在这个过程中，js 代码以字符串形式储存在 node 命名空间中，是不可直接执行的。启动 node 进程时，js 代码直接加载到内存中。")]),t._v(" "),a("h3",{attrs:{id:"_2-6-包与-npm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-包与-npm"}},[t._v("#")]),t._v(" 2.6 包与 NPM")]),t._v(" "),a("p",[t._v("CommonJS 的包规范由两部分组成：")]),t._v(" "),a("ul",[a("li",[t._v("包结构：用于组织包中的各种文件")]),t._v(" "),a("li",[t._v("包描述：描述包的相关信息，以供外部读取分析")])]),t._v(" "),a("ol",[a("li",[t._v("包结构"),a("br"),t._v("\n包实际上是一个存档文件，即一个格式为"),a("code",[t._v(".zip")]),t._v("或"),a("code",[t._v("tar.gz")]),t._v("的文件。安装后解压还原为目录。完整的 CommonJS 规范的包目录应该包含以下这些文件：")])]),t._v(" "),a("ul",[a("li",[t._v("package.json:包描述文件")]),t._v(" "),a("li",[t._v("bin:用于存放可执行二进制文件的目录。")]),t._v(" "),a("li",[t._v("lib:用于存放"),a("code",[t._v("JavaScript")]),t._v("代码的目录")]),t._v(" "),a("li",[t._v("doc:用于存放文档的目录")]),t._v(" "),a("li",[t._v("test:用于存放但愿测试用力的代码。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("包描述文件与 npm"),a("br"),t._v("\n包描述文件用于表达非代码相关的讯息，它是一个 JSON 格式的文件——"),a("code",[t._v("package.json")]),t._v("，位于包的根目录下。CommonJS 为 package.json 文件定义了如下一些字段：")])]),t._v(" "),a("ul",[a("li",[t._v("name:包名，由小写字母和数字组成，不允许出现空格，包名必须唯一")]),t._v(" "),a("li",[t._v("description 包简介")]),t._v(" "),a("li",[t._v("version 一个语义化的版本号，这在"),a("a",{attrs:{href:"http://semver.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://semver.org/"),a("OutboundLink")],1),t._v("上有详细定义。")]),t._v(" "),a("li",[t._v("keywords 关键词数组，影响 NPM 搜索")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("npm 常用功能")])]),t._v(" "),a("h2",{attrs:{id:"_3-异步-io"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-异步-io"}},[t._v("#")]),t._v(" 3. 异步 IO")]),t._v(" "),a("p",[t._v("3.2 安装依赖包执行安装命令后。npm 会在当前目录创建 node_modules，然后在 node_modules 下创建安装的包名文件夹,接着将包解压到这个文件夹下。")]),t._v(" "),a("ul",[a("li",[t._v("全局模式安装：将一个包安装为全局可用的可执行命令，根据包描述文件中的 bin 字段配置，将实际脚本链接到与 Node 可执行文件相同的路径下。如果 Node 可执行文件的位置是/usr/local/bin/node,那么模块目录就是/usr/local/lib/node_modules,最后通过软链接的方式将 bin 字段配置的可执行文件链接到 Node 的可之行目录下。")]),t._v(" "),a("li",[t._v("从本地安装：本地安装只需为 NPM 指明 package.json 文件所在的位置即可。它可以是一个包含 package.json 的存档文件，也可以是一个 URL 地址，也可以是一个有 package.json 文件的目录位置。例如：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("npm i <tarball file>\nnpm i <tarball url>\nnpm i <folder>\n")])])]),a("ul",[a("li",[a("p",[t._v("从非官方源安装：添加"),a("code",[t._v("--registry=http://registry.url")]),t._v("即可，例如"),a("code",[t._v("npm install underscore --registry=http://registry.url")]),t._v("。如果使用过程中都采用其他源安装，可以执行以下命令指定默认源："),a("code",[t._v("npm config set registry http://registry.url")])]),t._v(" "),a("p",[t._v("3.3 钩子命令 package.json 中 scripts 字段的提出就是让包在安装将活着写在等过程中提供钩子机制，例：")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('"scripts": {\n"preinstall": "preinstall.js",\n"install": "install.js",\n"uninstall": "uninstall.js",\n"test": "test.js"\n }\n')])])]),a("p",[t._v("在以上字段中执行"),a("code",[t._v("npm install <package>")]),t._v("时,preinstall 指向的脚本将会加载执行，然后 install 指向的脚本会被执行。在执行"),a("code",[t._v("npm uninstall <package>")]),t._v("时，uninstall 指向的脚本也许会做一些清理工作。 3.4 发布包")]),t._v(" "),a("ul",[a("li",[t._v("上传包："),a("code",[t._v("npm publish <folder>")]),t._v(",在这个过程中，npm 会将目录打包为一个存档文件，然后上传到官方源仓库中。")]),t._v(" "),a("li",[t._v("管理包权限：通常，一个包只有一个人拥有权限进行发布。如果多人进行发布，可以使用"),a("code",[t._v("npm owner")]),t._v("命令帮助你管理包的所有者：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("npm owner ls xxx // 查看包的所有者列表\nnpm owner add <user> <package name>\nnpm owner rm <user> <package name>\n")])])]),a("p",[t._v("3.5 分析包不能确认当前目录下能否通过 require()顺利引入想要的包，可以执行 npm ls 分析包。这个命令可以为你分析出当前路径下能狗通过模块路径找到的所有包，并生成依赖树.")]),t._v(" "),a("h3",{attrs:{id:"_3-2-异步-i-o-实现现状"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-异步-i-o-实现现状"}},[t._v("#")]),t._v(" 3.2 异步 I/O 实现现状")]),t._v(" "),a("ol",[a("li",[t._v("异步 I/O 与非阻塞 I/O"),a("br"),t._v("\n操作系统内核对于 IO 只有两种方式：阻塞和非阻塞。"),a("br"),t._v("\n阻塞 I/O 的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。阻塞 IO 造成 CPU 等待 IO，浪费等待时间。为了提高性能，内核提供了非阻塞 IO。非阻塞 IO 跟阻塞 IO 的区别为调用之后会立即返回。"),a("br"),t._v("\n但非阻塞 IO 也有一些问题，由于完整的的 IO 并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用 IO 操作来确认是否完成，这种重复调用判断操作是否完成的技术叫轮询。"),a("br"),t._v("\n非阻塞带来麻烦却是需要轮询去确认是否完成数据获取，它会让 CPU 处理状态判断，是对 CPU 资源的浪费。"),a("br"),t._v("\n现存的轮询技术有：")])]),t._v(" "),a("ul",[a("li",[t._v("read")]),t._v(" "),a("li",[t._v("select")]),t._v(" "),a("li",[t._v("poll")]),t._v(" "),a("li",[t._v("epoll")]),t._v(" "),a("li",[t._v("kqueue")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("现实的异步 I/O"),a("br"),t._v("\n之前的方案都不够好吗，这是在场景限定到了单线程的情况下，多线程的方式回事另一番风景。通过让部分现成进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个现成进行计算处理，通过现成之间的通信将 I/O 得到的数据进行传递，这就轻松实现了异步 I/O（尽管它是模拟的）")])]),t._v(" "),a("h3",{attrs:{id:"_3-3-node-的异步-i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-node-的异步-i-o"}},[t._v("#")]),t._v(" 3.3 Node 的异步 I/O")]),t._v(" "),a("p",[t._v("完成整个异步 I/O 环节的有"),a("code",[t._v("事件循环、观察者和请求对象")]),t._v("等。")]),t._v(" "),a("ol",[a("li",[t._v("事件循环"),a("br"),t._v("\nNode 自身的执行模型——事件循环。"),a("br"),t._v("\n在进程启动时，Node 便会创建一个类似于 while(true)的循环，没执行一次循环体的过程我们成为"),a("code",[t._v("Tick")]),t._v("。每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。 "),a("img",{attrs:{src:"https://blog-pic.oss-cn-beijing.aliyuncs.com/Node.js%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97_2020-10-09-22-13-22.png",alt:"Node.js使用指南_2020-10-09-22-13-22"}})]),t._v(" "),a("li",[t._v("观察者"),a("br"),t._v("\n在每个 Tick 的过程中，如何判断是否有事件需要处理呢？这里必须要引入的概念是观察者。"),a("br"),t._v("\n每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。"),a("br"),t._v("\n在 Node 中，手贱主要来源于网络请求、文件 I/O 等，这些事件对应的观察者有文件 I/O 观察者、网络 I/O 观察者等。观察者将事件进行了分类。"),a("br"),t._v("\n事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求等则是事件的生产者，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。"),a("br"),t._v("\n在 windows 下，这个循环基于 IOCP 创建，而在*nix 下则基于多线程创建。")])]),t._v(" "),a("h3",{attrs:{id:"_3-4-非-i-o-的异步-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-非-i-o-的异步-api"}},[t._v("#")]),t._v(" 3.4 非 I/O 的异步 API")]),t._v(" "),a("p",[t._v("Node 中还存在一些与 I/O 无关的异步 API，分别是："),a("code",[t._v("setTimeout()、setInterval()、setImmediate()、process.nextTick()")])]),t._v(" "),a("ol",[a("li",[t._v("定时器调用 setTimeout()或者 setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次 Tick 执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过就形成一个事件，它的回调函数将立即执行。")]),t._v(" "),a("li",[t._v("setImmediate() process.nextTick()中的回调函数执行的优先级要高于 setImmediate()。 这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于 idle 观察者， setImmediate()属于 check 观察者。在每一个轮循环检查中，idle 观察者先于 I/O 观察者，I/O 观察者先于 check 观察者。")])]),t._v(" "),a("p",[t._v("在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而 setImmediate()在每轮循环中执行链表中的一个回调函数。")]),t._v(" "),a("h2",{attrs:{id:"_5-内存控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-内存控制"}},[t._v("#")]),t._v(" 5. 内存控制")]),t._v(" "),a("h3",{attrs:{id:"_5-1-3-v8-的对象分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-3-v8-的对象分配"}},[t._v("#")]),t._v(" 5.1.3 v8 的对象分配")]),t._v(" "),a("p",[t._v("通过"),a("code",[t._v("memoryUsage")]),t._v("指令可以查看内存使用情况，heapTotal 和 heapUsed 是 V8 的堆内存使用情况，前者是已申请到的堆内存，后者是当前使用的量")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("node\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" process.memoryUsage"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，知道堆的大小超过 V8 的限制为止。"),a("br"),t._v(" "),a("strong",[t._v("为什么 V8 要限制内存使用呢？")]),a("br"),t._v("\n以 1.5GB 的垃圾祸首堆内存为例，v8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上。这是垃圾回收中引起 js 线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。")])])}),[],!1,null,null,null);s.default=n.exports}}]);