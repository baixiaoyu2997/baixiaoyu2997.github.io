(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{449:function(t,a,s){"use strict";s.r(a);var e=s(2),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"node特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node特点"}},[t._v("#")]),t._v(" Node特点")]),t._v(" "),s("h3",{attrs:{id:"_1-异步i-o"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-异步i-o"}},[t._v("#")]),t._v(" 1.异步I/O")]),t._v(" "),s("h3",{attrs:{id:"_2-事件与回掉函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-事件与回掉函数"}},[t._v("#")]),t._v(" 2.事件与回掉函数")]),t._v(" "),s("h3",{attrs:{id:"_3-单线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-单线程"}},[t._v("#")]),t._v(" 3.单线程")]),t._v(" "),s("p",[t._v("单线程的缺点：")]),t._v(" "),s("ul",[s("li",[t._v("无法利用多核处理器")]),t._v(" "),s("li",[t._v("错误会引起整个应用退出，应用的健壮性值得考验")]),t._v(" "),s("li",[t._v("大量计算占用cpu导致无法继续调用异步I/O")])]),t._v(" "),s("h3",{attrs:{id:"_4-跨平台"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-跨平台"}},[t._v("#")]),t._v(" 4.跨平台")]),t._v(" "),s("ul",[s("li",[t._v("操作系统与Node上层模块系统之间构建了一层平台层架构，即libuv")]),t._v(" "),s("li",[t._v("混合应用")])]),t._v(" "),s("h3",{attrs:{id:"_5-低资源占用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-低资源占用"}},[t._v("#")]),t._v(" 5.低资源占用")]),t._v(" "),s("ul",[s("li",[t._v("适合做云平台开发")])]),t._v(" "),s("h3",{attrs:{id:"_6-前端赋能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-前端赋能"}},[t._v("#")]),t._v(" 6.前端赋能")]),t._v(" "),s("ul",[s("li",[t._v("serverless")]),t._v(" "),s("li",[t._v("工具编写")]),t._v(" "),s("li",[t._v("桌面图形界面应用程序")])]),t._v(" "),s("h2",{attrs:{id:"node应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node应用场景"}},[t._v("#")]),t._v(" Node应用场景")]),t._v(" "),s("h3",{attrs:{id:"_1-i-o密集型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-i-o密集型"}},[t._v("#")]),t._v(" 1.I/O密集型")]),t._v(" "),s("p",[t._v("适合IO密集型，是因为js天生的异步写法，并不是比其他语言优秀，也因为node刚出的时候java对异步支持不是很好。")]),t._v(" "),s("h3",{attrs:{id:"_2-不擅长cpu密集型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-不擅长cpu密集型"}},[t._v("#")]),t._v(" 2.不擅长CPU密集型")]),t._v(" "),s("h3",{attrs:{id:"_3-与一流系统和平共处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-与一流系统和平共处"}},[t._v("#")]),t._v(" 3.与一流系统和平共处")]),t._v(" "),s("h3",{attrs:{id:"_4-分布式应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-分布式应用"}},[t._v("#")]),t._v(" 4.分布式应用")]),t._v(" "),s("h2",{attrs:{id:"node模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node模块"}},[t._v("#")]),t._v(" Node模块")]),t._v(" "),s("p",[t._v("在Node中引入模块，需要经历如下3个步骤：")]),t._v(" "),s("ol",[s("li",[t._v("路径分析")]),t._v(" "),s("li",[t._v("文件定位")]),t._v(" "),s("li",[t._v("编译执行")])]),t._v(" "),s("p",[t._v("在node中，模块分为两类：")]),t._v(" "),s("ol",[s("li",[t._v("核心模块：node提供的模块。核心模块部分在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中有限判断，所以它的加载速度时最快的。")]),t._v(" "),s("li",[t._v("文件模块：用户编写的模块。文件模块时在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。还有一种特殊的文件模版叫做"),s("code",[t._v("自定义模块")]),t._v("，这类模块的查找是最费时的，因为它是沿路径逐级递归查找node_modules目录")])]),t._v(" "),s("h3",{attrs:{id:"_2-2-1优先从缓存加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1优先从缓存加载"}},[t._v("#")]),t._v(" 2.2.1优先从缓存加载")]),t._v(" "),s("p",[t._v("Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同与浏览器的是，Node缓存的是编译和执行之后的对象。")]),t._v(" "),s("h3",{attrs:{id:"_2-2-2-路径分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-路径分析"}},[t._v("#")]),t._v(" 2.2.2 路径分析")]),t._v(" "),s("blockquote",[s("p",[t._v("require()方法接受一个标识符作为参数")])]),t._v(" "),s("ol",[s("li",[t._v("模块标识符分类")])]),t._v(" "),s("ul",[s("li",[t._v("核心模块，如"),s("code",[t._v("http、fs、path")])]),t._v(" "),s("li",[t._v(".或..开始的相对路径文件模块")]),t._v(" "),s("li",[t._v("以/开始的绝对路径文件模块")]),t._v(" "),s("li",[t._v("非路径形式的文件模块，也就是"),s("code",[t._v("自定义模块")])])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("文件定位")])]),t._v(" "),s("ul",[s("li",[t._v("文件扩展名分析\n"),s("ul",[s("li",[t._v("如果没有提供扩展名，则按照"),s("code",[t._v(".js、.json、.node")]),t._v("补足扩展名，依次尝试")])])]),t._v(" "),s("li",[t._v("目录分析和包\n"),s("ul",[s("li",[t._v("在require分析文件扩展名之后，可能没有找到对应文件，但是得到了一个目录，这在引入自定义模块和逐个模块路径进行查找时会出现，此时node会将目录当作一个包来处理")]),t._v(" "),s("li",[t._v("然后node对当前目录的package.json文件进行"),s("code",[t._v("JSON.parse()")]),t._v("解析，取出"),s("code",[t._v("main")]),t._v("的值对文件进行定位，如果缺少扩展名，则进入扩展名分析步骤")]),t._v(" "),s("li",[t._v("如果"),s("code",[t._v("main")]),t._v("属性指定的文件名错误，或者没有"),s("code",[t._v("package.json")]),t._v("文件，"),s("code",[t._v("node")]),t._v("会将"),s("code",[t._v("index")]),t._v("当作默认文件名,然后依次查找"),s("code",[t._v("index.js、index.json、index.node")])]),t._v(" "),s("li",[t._v("如果目录分析过程没有找到任何文件，则进入下一个模块路径进行查找。如果模块路径数组都没有查到，则抛出失败的异常。")])])])]),t._v(" "),s("h3",{attrs:{id:"_2-2-3-模块编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-模块编译"}},[t._v("#")]),t._v(" 2.2.3 模块编译")]),t._v(" "),s("p",[t._v("在node中，每个文件模块都是一个对象，它的定义如下：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Module")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" parent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("parent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" parent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("parent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" parent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("children"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    parent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("children"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("filename "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("loaded "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("children "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。不同的扩展名，编译方式不同：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v(".js")]),t._v("，通过"),s("code",[t._v("fs")]),t._v("模块同步读取文件后编译执行。")]),t._v(" "),s("li",[s("code",[t._v(".node")]),t._v("，这是用"),s("code",[t._v("c/c++")]),t._v("编写的扩展文件，通过"),s("code",[t._v("dlopen()")]),t._v("方法加载最后编译生成的文件。")]),t._v(" "),s("li",[s("code",[t._v(".json")]),t._v("，通过"),s("code",[t._v("fs")]),t._v("模块同步读取后，用"),s("code",[t._v("JSON.parse()")]),t._v("解析返回结果.")]),t._v(" "),s("li",[t._v("其他格式文件，都按照"),s("code",[t._v(".js")]),t._v("文件载入。")])]),t._v(" "),s("p",[t._v("每一个编译成功的模块都会将其文件路径作为索引缓存在"),s("code",[t._v("require.cache")]),t._v("对象上，以提高二次引入的性能")]),t._v(" "),s("p",[t._v("如果想对其他格式文件加载，可以通过扩展"),s("code",[t._v("require.extensions['.ext']")]),t._v("的方式实现。")]),t._v(" "),s("p",[t._v("但是从"),s("code",[t._v("v0.10.6")]),t._v("开始,官方不鼓励通过这种方式来进行加载，而是希望先将其他语言转换成js文件再加载，这样做的好处在于不将繁琐的编译加载等过程引入Node的执行过程中")]),t._v(" "),s("ol",[s("li",[t._v("JS模块的编译\n在"),s("code",[t._v("commonjs")]),t._v("规范中，我们知道每个模块存在"),s("code",[t._v("require、exports、module")]),t._v("三个变量，但是在模块文件中并没有被定义，为了防止污染全局变量，在编译的过程中，node对获取的js文件内容进行了头尾包装，头部添加"),s("code",[t._v("(function (exports, require, module, __filename, __dirname) {\\n")]),t._v(",尾部添加了"),s("code",[t._v("\\n});")]),t._v(",一个正常的js文件会被包装成如下的样子：")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("exports"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("require"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("module"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("__filename"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("__dirname")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" math "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'math'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  exports"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("area")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("radius")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Math"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PI")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" radius "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" radius"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("这样每个模块之间都进行了作用域隔离。包装之后的代码会被vm原声模块的"),s("code",[t._v("runInThisContext()")]),t._v("方法执行，返回一个具体的"),s("code",[t._v("function")]),t._v("对象，最后，将当前模块对象的"),s("code",[t._v("exports")]),t._v("属性、"),s("code",[t._v("require")]),t._v("方法、"),s("code",[t._v("module（模块对象自身）")]),t._v(",以及在文件定位中得到的完整路径和文件目录作为参数传递给这个"),s("code",[t._v("function()")]),t._v("执行。\n1.1 exports和module.exports"),s("br"),t._v("\n因为exports是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值，比如：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("change")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n  a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 100")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("change")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 10")]),t._v("\n")])])]),s("p",[t._v("如果要达到require引入一个类的效果，请赋值给module.exports对象。这个迂回的方案不改变形参的引用。")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("C/C++模块的编译\n.node的模块不需要编译，只有加载和执行的过程，在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。")]),t._v(" "),s("li",[t._v("JSON的文件的编译\nnode利用fs模块读取json文件的内容之后，调用JSON.parse方法得到对象，然后将它赋给模块对象"),s("code",[t._v("exports")]),t._v("，以供外部使用")])]),t._v(" "),s("h3",{attrs:{id:"_2-3-核心模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-核心模块"}},[t._v("#")]),t._v(" 2.3 核心模块")]),t._v(" "),s("p",[t._v("核心模块分为c/c++和js编写的两部分，c/c++文件存放在Node项目下的src目录，javascript文件存放在lib目录下。")]),t._v(" "),s("h3",{attrs:{id:"_2-3-1-js核心模块的编译过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-js核心模块的编译过程"}},[t._v("#")]),t._v(" 2.3.1 js核心模块的编译过程")]),t._v(" "),s("p",[t._v("在编译所有C/C++文件之前，编译程序需要将所有的js模块文件编译为C/C++代码")]),t._v(" "),s("ol",[s("li",[t._v("转存为C/C++代码\nNode采用了V8附带的js2c.py工具，将所有内置的js代码（src/node.js和lib/*.js）转换成C++里的数组，生成C++里的数组，生成node_natives.h头文件:")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('namespace node {\nconst char node_native[] = { 47, 47, ..};\nconst char dgram_native[] = { 47, 47, ..};\nconst char console_native[] = { 47, 47, ..}; const char buffer_native[] = { 47, 47, ..}; const char querystring_native[] = { 47, 47, ..}; const char punycode_native[] = { 47, 42, ..};\n...\nstruct _native { const char* name; const char* source; size_t source_len;\n};\nstatic const struct _native natives[] = {\n{ "node", node_native, sizeof(node_native)-1 },\n{ "dgram", dgram_native, sizeof(dgram_native)-1 }, ...\n};\n     }\n')])])]),s("p",[t._v("在这个过程中，js代码以字符串形式储存在node命名空间中，是不可直接执行的。启动node进程时，js代码直接加载到内存中。")]),t._v(" "),s("h3",{attrs:{id:"_2-6-包与npm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-包与npm"}},[t._v("#")]),t._v(" 2.6 包与NPM")]),t._v(" "),s("p",[t._v("CommonJS的包规范由两部分组成：")]),t._v(" "),s("ul",[s("li",[t._v("包结构：用于组织包中的各种文件")]),t._v(" "),s("li",[t._v("包描述：描述包的相关信息，以供外部读取分析")])]),t._v(" "),s("h3",{attrs:{id:"_2-6-1-包结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-1-包结构"}},[t._v("#")]),t._v(" 2.6.1 包结构")]),t._v(" "),s("p",[t._v("包实际上是一个存档文件，即一个格式为"),s("code",[t._v(".zip")]),t._v("或"),s("code",[t._v("tar.gz")]),t._v("的文件。安装后解压还原为目录。完整的CommonJS规范的包目录应该包含以下这些文件：")]),t._v(" "),s("ul",[s("li",[t._v("package.json:包描述文件")]),t._v(" "),s("li",[t._v("bin:用于存放可执行二进制文件的目录。")]),t._v(" "),s("li",[t._v("lib:用于存放"),s("code",[t._v("JavaScript")]),t._v("代码的目录")]),t._v(" "),s("li",[t._v("doc:用于存放文档的目录")]),t._v(" "),s("li",[t._v("test:用于存放但愿测试用力的代码。")])]),t._v(" "),s("h3",{attrs:{id:"_2-6-2-包描述文件与npm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-2-包描述文件与npm"}},[t._v("#")]),t._v(" 2.6.2 包描述文件与npm")]),t._v(" "),s("p",[t._v("包描述文件用于表达非代码相关的讯息，它是一个JSON格式的文件——"),s("code",[t._v("package.json")]),t._v("，位于包的根目录下。CommonJS为package.json文件定义了如下一些字段：")]),t._v(" "),s("ul",[s("li",[t._v("name:包名，由小写字母和数字组成，不允许出现空格，包名必须唯一")]),t._v(" "),s("li",[t._v("description 包简介")]),t._v(" "),s("li",[t._v("version 一个语义化的版本号，这在"),s("a",{attrs:{href:"http://semver.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://semver.org/"),s("OutboundLink")],1),t._v("上有详细定义。")]),t._v(" "),s("li",[t._v("keywords 关键词数组，影响NPM搜索")])]),t._v(" "),s("h3",{attrs:{id:"_2-6-3-npm常用功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-3-npm常用功能"}},[t._v("#")]),t._v(" 2.6.3 npm常用功能")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("安装依赖包\n执行安装命令后。npm会在当前目录创建node_modules，然后在node_modules下创建安装的包名文件夹,接着将包解压到这个文件夹下。")])]),t._v(" "),s("ul",[s("li",[t._v("全局模式安装：将一个包安装为全局可用的可执行命令，根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同的路径下。如果Node可执行文件的位置是/usr/local/bin/node,那么模块目录就是/usr/local/lib/node_modules,最后通过软链接的方式将bin字段配置的可执行文件链接到Node的可之行目录下。")]),t._v(" "),s("li",[t._v("从本地安装：本地安装只需为NPM指明package.json文件所在的位置即可。它可以是一个包含package.json的存档文件，也可以是一个URL地址，也可以是一个有package.json文件的目录位置。例如：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("npm i <tarball file>\nnpm i <tarball url>\nnpm i <folder>\n")])])]),s("ul",[s("li",[t._v("从非官方源安装：添加"),s("code",[t._v("--registry=http://registry.url")]),t._v("即可，例如"),s("code",[t._v("npm install underscore --registry=http://registry.url")]),t._v("。如果使用过程中都采用其他源安装，可以执行以下命令指定默认源："),s("code",[t._v("npm config set registry http://registry.url")])])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("钩子命令\npackage.json中scripts字段的提出就是让包在安装将活着写在等过程中提供钩子机制，例：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('"scripts": {\n"preinstall": "preinstall.js", \n"install": "install.js", \n"uninstall": "uninstall.js", \n"test": "test.js"\n }\n')])])]),s("p",[t._v("在以上字段中执行"),s("code",[t._v("npm install <package>")]),t._v("时,preinstall指向的脚本将会加载执行，然后install指向的脚本会被执行。在执行"),s("code",[t._v("npm uninstall <package>")]),t._v("时，uninstall指向的脚本也许会做一些清理工作。\n4. 发布包")]),t._v(" "),s("ul",[s("li",[t._v("上传包："),s("code",[t._v("npm publish <folder>")]),t._v(",在这个过程中，npm会将目录打包为一个存档文件，然后上传到官方源仓库中。")]),t._v(" "),s("li",[t._v("管理包权限：通常，一个包只有一个人拥有权限进行发布。如果多人进行发布，可以使用"),s("code",[t._v("npm owner")]),t._v("命令帮助你管理包的所有者：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("npm owner ls xxx // 查看包的所有者列表\nnpm owner add <user> <package name>\nnpm owner rm <user> <package name>\n")])])]),s("ol",{attrs:{start:"5"}},[s("li",[t._v("分析包\n不能确认当前目录下能否通过require()顺利引入想要的包，可以执行npm ls分析包。这个命令可以为你分析出当前路径下能狗通过模块路径找到的所有包，并生成依赖树.")])]),t._v(" "),s("h2",{attrs:{id:"file-system"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#file-system"}},[t._v("#")]),t._v(" File System")]),t._v(" "),s("h3",{attrs:{id:"fs-mkdirsync-path-options"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fs-mkdirsync-path-options"}},[t._v("#")]),t._v(" fs.mkdirSync(path[, options])")]),t._v(" "),s("p",[t._v("同步地创建目录。 返回 undefined，或创建的第一个目录的路径（如果 recursive 为 true）。 这是 fs.mkdir() 的同步版本。")]),t._v(" "),s("h3",{attrs:{id:"fs-writefilesync-file-data-options"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fs-writefilesync-file-data-options"}},[t._v("#")]),t._v(" fs.writeFileSync(file, data[, options])")]),t._v(" "),s("p",[t._v("当 file 是文件名时，则异步地写入数据到文件（如果文件已存在，则覆盖文件）。 data 可以是字符串或 buffer。")]),t._v(" "),s("p",[t._v("当 file 是文件描述符时，则其行为类似于直接调用 fs.write()（建议使用）。 参见以下关于使用文件描述符的说明。")]),t._v(" "),s("p",[t._v("如果 data 是 buffer，则 encoding 选项会被忽略。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("const data = new Uint8Array(Buffer.from('Node.js 中文网'));\nfs.writeFile('文件.txt', data, (err) => {\n  if (err) throw err;\n  console.log('文件已被保存');\n});\n")])])]),s("p",[t._v("返回 undefined。")]),t._v(" "),s("h2",{attrs:{id:"modules"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#modules"}},[t._v("#")]),t._v(" Modules")]),t._v(" "),s("h3",{attrs:{id:"module-paths"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#module-paths"}},[t._v("#")]),t._v(" module.paths")]),t._v(" "),s("p",[t._v("模块的搜索路径")]),t._v(" "),s("h2",{attrs:{id:"path"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#path"}},[t._v("#")]),t._v(" Path")]),t._v(" "),s("h3",{attrs:{id:"path-join-paths"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#path-join-paths"}},[t._v("#")]),t._v(" path.join([...paths])")]),t._v(" "),s("p",[t._v("path.join() 方法使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。\n零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 '.'，表示当前工作目录。")]),t._v(" "),s("h2",{attrs:{id:"process-进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#process-进程"}},[t._v("#")]),t._v(" process(进程)")]),t._v(" "),s("p",[s("code",[t._v("process")]),t._v(" 对象是一个全局变量，提供了有关当前 "),s("code",[t._v("Node.js")]),t._v(" 进程的信息并对其进行控制。 作为全局变量，它始终可供 "),s("code",[t._v("Node.js")]),t._v(" 应用程序使用，无需使用 "),s("code",[t._v("require()")]),t._v("。 它也可以使用"),s("code",[t._v("require()")]),t._v(" 显式地访问：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" process "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'process'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h3",{attrs:{id:"process-argv"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#process-argv"}},[t._v("#")]),t._v(" process.argv")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("<string[]>")])])]),t._v(" "),s("p",[s("code",[t._v("process.argv")]),t._v(" 属性会返回一个数组，其中包含当 "),s("code",[t._v("Node.js")]),t._v(" 进程被启动时传入的命令行参数。 第一个元素是 "),s("code",[t._v("process.execPath")]),t._v("。 第二个元素是正被执行的 "),s("code",[t._v("JavaScript")]),t._v(" 文件的路径。 其余的元素是任何额外的命令行参数。所有参数都为字符串")]),t._v(" "),s("h2",{attrs:{id:"require"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#require"}},[t._v("#")]),t._v(" require")]),t._v(" "),s("h3",{attrs:{id:"require-extentions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#require-extentions"}},[t._v("#")]),t._v(" require.extentions")]),t._v(" "),s("p",[t._v("系统中已有的扩展加载方式，正常情况是"),s("code",[t._v(".js、.json、.node")]),t._v(",得到的结果：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("{ '.js': [Function], '.json': [Function], '.node': [Function] }\n")])])]),s("h3",{attrs:{id:"require-cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#require-cache"}},[t._v("#")]),t._v(" require.cache")]),t._v(" "),s("p",[t._v("加载模块的缓存路径映射，加速下一次加载")]),t._v(" "),s("h2",{attrs:{id:"问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),s("h3",{attrs:{id:"node中启用import"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node中启用import"}},[t._v("#")]),t._v(" node中启用import？")]),t._v(" "),s("blockquote",[s("p",[t._v("前置条件: "),s("code",[t._v("node")]),t._v("命令后添加"),s("code",[t._v("--experimental-modules")]),t._v("参数，例如："),s("code",[t._v("node --experimental-modules test.js")])])]),t._v(" "),s("p",[t._v("在"),s("code",[t._v("node v12")]),t._v("中有三种方法：")]),t._v(" "),s("ol",[s("li",[t._v("文件以"),s("code",[t._v(".ejs")]),t._v("结尾")]),t._v(" "),s("li",[t._v("最近的"),s("code",[t._v("package.json")]),t._v("中添加"),s("code",[t._v("'type':'module'")])]),t._v(" "),s("li",[t._v("Strings passed in as an argument to --eval or --print, or piped to node via STDIN, with the flag --input-type=module.")])]),t._v(" "),s("p",[t._v("我使用的是第二种方法")]),t._v(" "),s("h3",{attrs:{id:"当type-module-时-就不能再使用require"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当type-module-时-就不能再使用require"}},[t._v("#")]),t._v(" 当type=‘module’时，就不能再使用require？")]),t._v(" "),s("p",[t._v("可以使用 module.createRequire()替代，更多关于ES Modules 和 CommonJS的用法区别，可以查看：https://nodejs.org/api/esm.html#esm_differences_between_es_modules_and_commonjs")])])}),[],!1,null,null,null);a.default=n.exports}}]);