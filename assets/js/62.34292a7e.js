(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{485:function(t,s,a){"use strict";a.r(s);var n=a(2),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-node简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-node简介"}},[t._v("#")]),t._v(" 1. Node简介")]),t._v(" "),a("h3",{attrs:{id:"_1-异步i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-异步i-o"}},[t._v("#")]),t._v(" 1.异步I/O")]),t._v(" "),a("h3",{attrs:{id:"_2-事件与回掉函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-事件与回掉函数"}},[t._v("#")]),t._v(" 2.事件与回掉函数")]),t._v(" "),a("h3",{attrs:{id:"_3-单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-单线程"}},[t._v("#")]),t._v(" 3.单线程")]),t._v(" "),a("p",[t._v("单线程的缺点：")]),t._v(" "),a("ul",[a("li",[t._v("无法利用多核处理器")]),t._v(" "),a("li",[t._v("错误会引起整个应用退出，应用的健壮性值得考验")]),t._v(" "),a("li",[t._v("大量计算占用cpu导致无法继续调用异步I/O")])]),t._v(" "),a("h3",{attrs:{id:"_4-跨平台"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-跨平台"}},[t._v("#")]),t._v(" 4.跨平台")]),t._v(" "),a("ul",[a("li",[t._v("操作系统与Node上层模块系统之间构建了一层平台层架构，即libuv")]),t._v(" "),a("li",[t._v("混合应用")])]),t._v(" "),a("h3",{attrs:{id:"_5-低资源占用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-低资源占用"}},[t._v("#")]),t._v(" 5.低资源占用")]),t._v(" "),a("ul",[a("li",[t._v("适合做云平台开发")])]),t._v(" "),a("h3",{attrs:{id:"_6-前端赋能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-前端赋能"}},[t._v("#")]),t._v(" 6.前端赋能")]),t._v(" "),a("ul",[a("li",[t._v("serverless")]),t._v(" "),a("li",[t._v("工具编写")]),t._v(" "),a("li",[t._v("桌面图形界面应用程序")])]),t._v(" "),a("h3",{attrs:{id:"_1-5-node应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-node应用场景"}},[t._v("#")]),t._v(" 1.5 Node应用场景")]),t._v(" "),a("ol",[a("li",[t._v("I/O密集型\n适合IO密集型，是因为js天生的异步写法，并不是比其他语言优秀，也因为node刚出的时候java对异步支持不是很好。")]),t._v(" "),a("li",[t._v("不擅长CPU密集型")]),t._v(" "),a("li",[t._v("与一流系统和平共处")]),t._v(" "),a("li",[t._v("分布式应用")])]),t._v(" "),a("h2",{attrs:{id:"_2-模块机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-模块机制"}},[t._v("#")]),t._v(" 2. 模块机制")]),t._v(" "),a("p",[t._v("在Node中引入模块，需要经历如下3个步骤：")]),t._v(" "),a("ol",[a("li",[t._v("路径分析")]),t._v(" "),a("li",[t._v("文件定位")]),t._v(" "),a("li",[t._v("编译执行")])]),t._v(" "),a("p",[t._v("在node中，模块分为两类：")]),t._v(" "),a("ol",[a("li",[t._v("核心模块：node提供的模块。核心模块部分在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中有限判断，所以它的加载速度时最快的。")]),t._v(" "),a("li",[t._v("文件模块：用户编写的模块。文件模块时在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。还有一种特殊的文件模版叫做"),a("code",[t._v("自定义模块")]),t._v("，这类模块的查找是最费时的，因为它是沿路径逐级递归查找node_modules目录")])]),t._v(" "),a("h3",{attrs:{id:"_2-2-node的模块实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-node的模块实现"}},[t._v("#")]),t._v(" 2.2 Node的模块实现")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("优先从缓存加载\nNode对引入过的模块都会进行缓存，以减少二次引入时的开销。不同与浏览器的是，Node缓存的是编译和执行之后的对象。")])]),t._v(" "),a("li",[a("p",[t._v("路径分析")])])]),t._v(" "),a("blockquote",[a("p",[t._v("require()方法接受一个标识符作为参数")])]),t._v(" "),a("p",[t._v("1.1 模块标识符分类")]),t._v(" "),a("ul",[a("li",[t._v("核心模块，如"),a("code",[t._v("http、fs、path")])]),t._v(" "),a("li",[t._v(".或..开始的相对路径文件模块")]),t._v(" "),a("li",[t._v("以/开始的绝对路径文件模块")]),t._v(" "),a("li",[t._v("非路径形式的文件模块，也就是"),a("code",[t._v("自定义模块")])])]),t._v(" "),a("p",[t._v("1.2 文件定位")]),t._v(" "),a("ul",[a("li",[t._v("文件扩展名分析\n"),a("ul",[a("li",[t._v("如果没有提供扩展名，则按照"),a("code",[t._v(".js、.json、.node")]),t._v("补足扩展名，依次尝试")])])]),t._v(" "),a("li",[t._v("目录分析和包\n"),a("ul",[a("li",[t._v("在require分析文件扩展名之后，可能没有找到对应文件，但是得到了一个目录，这在引入自定义模块和逐个模块路径进行查找时会出现，此时node会将目录当作一个包来处理")]),t._v(" "),a("li",[t._v("然后node对当前目录的package.json文件进行"),a("code",[t._v("JSON.parse()")]),t._v("解析，取出"),a("code",[t._v("main")]),t._v("的值对文件进行定位，如果缺少扩展名，则进入扩展名分析步骤")]),t._v(" "),a("li",[t._v("如果"),a("code",[t._v("main")]),t._v("属性指定的文件名错误，或者没有"),a("code",[t._v("package.json")]),t._v("文件，"),a("code",[t._v("node")]),t._v("会将"),a("code",[t._v("index")]),t._v("当作默认文件名,然后依次查找"),a("code",[t._v("index.js、index.json、index.node")])]),t._v(" "),a("li",[t._v("如果目录分析过程没有找到任何文件，则进入下一个模块路径进行查找。如果模块路径数组都没有查到，则抛出失败的异常。\n1.3 模块编译"),a("br"),t._v("\n在node中，每个文件模块都是一个对象，它的定义如下：")])])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Module")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" parent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("parent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" parent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("parent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" parent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("children"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    parent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("children"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("filename "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("loaded "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("children "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。不同的扩展名，编译方式不同：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v(".js")]),t._v("，通过"),a("code",[t._v("fs")]),t._v("模块同步读取文件后编译执行。")]),t._v(" "),a("li",[a("code",[t._v(".node")]),t._v("，这是用"),a("code",[t._v("c/c++")]),t._v("编写的扩展文件，通过"),a("code",[t._v("dlopen()")]),t._v("方法加载最后编译生成的文件。")]),t._v(" "),a("li",[a("code",[t._v(".json")]),t._v("，通过"),a("code",[t._v("fs")]),t._v("模块同步读取后，用"),a("code",[t._v("JSON.parse()")]),t._v("解析返回结果.")]),t._v(" "),a("li",[t._v("其他格式文件，都按照"),a("code",[t._v(".js")]),t._v("文件载入。")])]),t._v(" "),a("p",[t._v("每一个编译成功的模块都会将其文件路径作为索引缓存在"),a("code",[t._v("require.cache")]),t._v("对象上，以提高二次引入的性能")]),t._v(" "),a("p",[t._v("如果想对其他格式文件加载，可以通过扩展"),a("code",[t._v("require.extensions['.ext']")]),t._v("的方式实现。")]),t._v(" "),a("p",[t._v("但是从"),a("code",[t._v("v0.10.6")]),t._v("开始,官方不鼓励通过这种方式来进行加载，而是希望先将其他语言转换成js文件再加载，这样做的好处在于不将繁琐的编译加载等过程引入Node的执行过程中")]),t._v(" "),a("ol",[a("li",[t._v("JS模块的编译\n在"),a("code",[t._v("commonjs")]),t._v("规范中，我们知道每个模块存在"),a("code",[t._v("require、exports、module")]),t._v("三个变量，但是在模块文件中并没有被定义，为了防止污染全局变量，在编译的过程中，node对获取的js文件内容进行了头尾包装，头部添加"),a("code",[t._v("(function (exports, require, module, __filename, __dirname) {\\n")]),t._v(",尾部添加了"),a("code",[t._v("\\n});")]),t._v(",一个正常的js文件会被包装成如下的样子：")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("exports"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("require"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("__filename"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("__dirname")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" math "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'math'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  exports"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("area")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("radius")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Math"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PI")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" radius "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" radius"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("这样每个模块之间都进行了作用域隔离。包装之后的代码会被vm原声模块的"),a("code",[t._v("runInThisContext()")]),t._v("方法执行，返回一个具体的"),a("code",[t._v("function")]),t._v("对象，最后，将当前模块对象的"),a("code",[t._v("exports")]),t._v("属性、"),a("code",[t._v("require")]),t._v("方法、"),a("code",[t._v("module（模块对象自身）")]),t._v(",以及在文件定位中得到的完整路径和文件目录作为参数传递给这个"),a("code",[t._v("function()")]),t._v("执行。\n1.1 exports和module.exports"),a("br"),t._v("\n因为exports是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值，比如：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("change")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n  a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 100")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("change")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 10")]),t._v("\n")])])]),a("p",[t._v("如果要达到require引入一个类的效果，请赋值给module.exports对象。这个迂回的方案不改变形参的引用。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("C/C++模块的编译\n.node的模块不需要编译，只有加载和执行的过程，在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。")]),t._v(" "),a("li",[t._v("JSON的文件的编译\nnode利用fs模块读取json文件的内容之后，调用JSON.parse方法得到对象，然后将它赋给模块对象"),a("code",[t._v("exports")]),t._v("，以供外部使用")])]),t._v(" "),a("h3",{attrs:{id:"_2-3-核心模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-核心模块"}},[t._v("#")]),t._v(" 2.3 核心模块")]),t._v(" "),a("p",[t._v("核心模块分为c/c++和js编写的两部分，c/c++文件存放在Node项目下的src目录，javascript文件存放在lib目录下。")]),t._v(" "),a("ol",[a("li",[t._v("js核心模块的编译过程"),a("br"),t._v("\n在编译所有C/C++文件之前，编译程序需要将所有的js模块文件编译为C/C++代码。\n"),a("ol",[a("li",[t._v("转存为C/C++代码\nNode采用了V8附带的js2c.py工具，将所有内置的js代码（src/node.js和lib/*.js）转换成C++里的数组，生成C++里的数组，生成node_natives.h头文件:")])])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('namespace node {\nconst char node_native[] = { 47, 47, ..};\nconst char dgram_native[] = { 47, 47, ..};\nconst char console_native[] = { 47, 47, ..}; const char buffer_native[] = { 47, 47, ..}; const char querystring_native[] = { 47, 47, ..}; const char punycode_native[] = { 47, 42, ..};\n...\nstruct _native { const char* name; const char* source; size_t source_len;\n};\nstatic const struct _native natives[] = {\n{ "node", node_native, sizeof(node_native)-1 },\n{ "dgram", dgram_native, sizeof(dgram_native)-1 }, ...\n};\n     }\n')])])]),a("p",[t._v("在这个过程中，js代码以字符串形式储存在node命名空间中，是不可直接执行的。启动node进程时，js代码直接加载到内存中。")]),t._v(" "),a("h3",{attrs:{id:"_2-6-包与npm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-包与npm"}},[t._v("#")]),t._v(" 2.6 包与NPM")]),t._v(" "),a("p",[t._v("CommonJS的包规范由两部分组成：")]),t._v(" "),a("ul",[a("li",[t._v("包结构：用于组织包中的各种文件")]),t._v(" "),a("li",[t._v("包描述：描述包的相关信息，以供外部读取分析")])]),t._v(" "),a("ol",[a("li",[t._v("包结构"),a("br"),t._v("\n包实际上是一个存档文件，即一个格式为"),a("code",[t._v(".zip")]),t._v("或"),a("code",[t._v("tar.gz")]),t._v("的文件。安装后解压还原为目录。完整的CommonJS规范的包目录应该包含以下这些文件：")])]),t._v(" "),a("ul",[a("li",[t._v("package.json:包描述文件")]),t._v(" "),a("li",[t._v("bin:用于存放可执行二进制文件的目录。")]),t._v(" "),a("li",[t._v("lib:用于存放"),a("code",[t._v("JavaScript")]),t._v("代码的目录")]),t._v(" "),a("li",[t._v("doc:用于存放文档的目录")]),t._v(" "),a("li",[t._v("test:用于存放但愿测试用力的代码。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("包描述文件与npm"),a("br"),t._v("\n包描述文件用于表达非代码相关的讯息，它是一个JSON格式的文件——"),a("code",[t._v("package.json")]),t._v("，位于包的根目录下。CommonJS为package.json文件定义了如下一些字段：")])]),t._v(" "),a("ul",[a("li",[t._v("name:包名，由小写字母和数字组成，不允许出现空格，包名必须唯一")]),t._v(" "),a("li",[t._v("description 包简介")]),t._v(" "),a("li",[t._v("version 一个语义化的版本号，这在"),a("a",{attrs:{href:"http://semver.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://semver.org/"),a("OutboundLink")],1),t._v("上有详细定义。")]),t._v(" "),a("li",[t._v("keywords 关键词数组，影响NPM搜索")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("npm常用功能")])]),t._v(" "),a("h2",{attrs:{id:"_3-异步io"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-异步io"}},[t._v("#")]),t._v(" 3. 异步IO")]),t._v(" "),a("p",[t._v("3.2 安装依赖包\n执行安装命令后。npm会在当前目录创建node_modules，然后在node_modules下创建安装的包名文件夹,接着将包解压到这个文件夹下。")]),t._v(" "),a("ul",[a("li",[t._v("全局模式安装：将一个包安装为全局可用的可执行命令，根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同的路径下。如果Node可执行文件的位置是/usr/local/bin/node,那么模块目录就是/usr/local/lib/node_modules,最后通过软链接的方式将bin字段配置的可执行文件链接到Node的可之行目录下。")]),t._v(" "),a("li",[t._v("从本地安装：本地安装只需为NPM指明package.json文件所在的位置即可。它可以是一个包含package.json的存档文件，也可以是一个URL地址，也可以是一个有package.json文件的目录位置。例如：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("npm i <tarball file>\nnpm i <tarball url>\nnpm i <folder>\n")])])]),a("ul",[a("li",[t._v("从非官方源安装：添加"),a("code",[t._v("--registry=http://registry.url")]),t._v("即可，例如"),a("code",[t._v("npm install underscore --registry=http://registry.url")]),t._v("。如果使用过程中都采用其他源安装，可以执行以下命令指定默认源："),a("code",[t._v("npm config set registry http://registry.url")])])]),t._v(" "),a("p",[t._v("3.3 钩子命令\npackage.json中scripts字段的提出就是让包在安装将活着写在等过程中提供钩子机制，例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('"scripts": {\n"preinstall": "preinstall.js", \n"install": "install.js", \n"uninstall": "uninstall.js", \n"test": "test.js"\n }\n')])])]),a("p",[t._v("在以上字段中执行"),a("code",[t._v("npm install <package>")]),t._v("时,preinstall指向的脚本将会加载执行，然后install指向的脚本会被执行。在执行"),a("code",[t._v("npm uninstall <package>")]),t._v("时，uninstall指向的脚本也许会做一些清理工作。\n3.4 发布包")]),t._v(" "),a("ul",[a("li",[t._v("上传包："),a("code",[t._v("npm publish <folder>")]),t._v(",在这个过程中，npm会将目录打包为一个存档文件，然后上传到官方源仓库中。")]),t._v(" "),a("li",[t._v("管理包权限：通常，一个包只有一个人拥有权限进行发布。如果多人进行发布，可以使用"),a("code",[t._v("npm owner")]),t._v("命令帮助你管理包的所有者：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("npm owner ls xxx // 查看包的所有者列表\nnpm owner add <user> <package name>\nnpm owner rm <user> <package name>\n")])])]),a("p",[t._v("3.5 分析包\n不能确认当前目录下能否通过require()顺利引入想要的包，可以执行npm ls分析包。这个命令可以为你分析出当前路径下能狗通过模块路径找到的所有包，并生成依赖树.")]),t._v(" "),a("h3",{attrs:{id:"_3-2-异步i-o实现现状"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-异步i-o实现现状"}},[t._v("#")]),t._v(" 3.2 异步I/O实现现状")]),t._v(" "),a("ol",[a("li",[t._v("异步I/O与非阻塞I/O"),a("br"),t._v("\n操作系统内核对于IO只有两种方式：阻塞和非阻塞。"),a("br"),t._v("\n阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。阻塞IO造成CPU等待IO，浪费等待时间。为了提高性能，内核提供了非阻塞IO。非阻塞IO跟阻塞IO的区别为调用之后会立即返回。"),a("br"),t._v("\n但非阻塞IO也有一些问题，由于完整的的IO并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用IO操作来确认是否完成，这种重复调用判断操作是否完成的技术叫轮询。"),a("br"),t._v("\n非阻塞带来麻烦却是需要轮询去确认是否完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费。"),a("br"),t._v("\n现存的轮询技术有：")])]),t._v(" "),a("ul",[a("li",[t._v("read")]),t._v(" "),a("li",[t._v("select")]),t._v(" "),a("li",[t._v("poll")]),t._v(" "),a("li",[t._v("epoll")]),t._v(" "),a("li",[t._v("kqueue")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("现实的异步I/O"),a("br"),t._v("\n之前的方案都不够好吗，这是在场景限定到了单线程的情况下，多线程的方式回事另一番风景。通过让部分现成进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个现成进行计算处理，通过现成之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O（尽管它是模拟的）")])]),t._v(" "),a("h3",{attrs:{id:"_3-3-node的异步i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-node的异步i-o"}},[t._v("#")]),t._v(" 3.3 Node的异步I/O")]),t._v(" "),a("p",[t._v("完成整个异步I/O环节的有"),a("code",[t._v("事件循环、观察者和请求对象")]),t._v("等。")]),t._v(" "),a("ol",[a("li",[t._v("事件循环"),a("br"),t._v("\nNode自身的执行模型——事件循环。"),a("br"),t._v("\n在进程启动时，Node便会创建一个类似于while(true)的循环，没执行一次循环体的过程我们成为"),a("code",[t._v("Tick")]),t._v("。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。\n"),a("img",{attrs:{src:"https://blog-pic.oss-cn-beijing.aliyuncs.com/Node.js%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97_2020-10-09-22-13-22.png",alt:"Node.js使用指南_2020-10-09-22-13-22"}})]),t._v(" "),a("li",[t._v("观察者"),a("br"),t._v("\n在每个Tick的过程中，如何判断是否有事件需要处理呢？这里必须要引入的概念是观察者。"),a("br"),t._v("\n每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。"),a("br"),t._v("\n在Node中，手贱主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。"),a("br"),t._v("\n事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。"),a("br"),t._v("\n在windows下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。")])]),t._v(" "),a("h3",{attrs:{id:"_3-4-非i-o的异步api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-非i-o的异步api"}},[t._v("#")]),t._v(" 3.4 非I/O的异步API")]),t._v(" "),a("p",[t._v("Node中还存在一些与I/O无关的异步API，分别是："),a("code",[t._v("setTimeout()、setInterval()、setImmediate()、process.nextTick()")])]),t._v(" "),a("ol",[a("li",[t._v("定时器\n调用setTimeout()或者 setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过就形成一个事件，它的回调函数将立即执行。")]),t._v(" "),a("li",[t._v("setImmediate()\nprocess.nextTick()中的回调函数执行的优先级要高于setImmediate()。 这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者， setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。"),a("br"),t._v("\n在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。")])]),t._v(" "),a("h2",{attrs:{id:"_4-异步编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-异步编程"}},[t._v("#")]),t._v(" 4.   异步编程")]),t._v(" "),a("h3",{attrs:{id:"_4-1-函数式编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-函数式编程"}},[t._v("#")]),t._v(" 4.1 函数式编程")])])}),[],!1,null,null,null);s.default=e.exports}}]);