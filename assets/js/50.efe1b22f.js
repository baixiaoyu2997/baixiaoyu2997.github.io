(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{444:function(t,a,s){"use strict";s.r(a);var r=s(1),e=Object(r.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#规范","aria-hidden":"true"}},[t._v("#")]),t._v(" 规范")]),t._v(" "),s("ol",[s("li",[s("a",{attrs:{href:"https://github.com/tc39/ecma262",target:"_blank",rel:"noopener noreferrer"}},[t._v("ecma262"),s("OutboundLink")],1)])]),t._v(" "),s("blockquote",[s("p",[t._v("ECMA-262的状态、进程和文档")])]),t._v(" "),s("h2",{attrs:{id:"内置对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内置对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 内置对象")]),t._v(" "),s("h3",{attrs:{id:"object"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object","aria-hidden":"true"}},[t._v("#")]),t._v(" Object")]),t._v(" "),s("ul",[s("li",[t._v("Object.keys()\n"),s("ul",[s("li",[t._v("操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替 ​​​​")])])])]),t._v(" "),s("h3",{attrs:{id:"promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[t._v("#")]),t._v(" Promise")]),t._v(" "),s("p",[t._v("new Promise会立即执行，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行")]),t._v(" "),s("h2",{attrs:{id:"语句和声明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语句和声明","aria-hidden":"true"}},[t._v("#")]),t._v(" 语句和声明")]),t._v(" "),s("h3",{attrs:{id:"try-catch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#try-catch","aria-hidden":"true"}},[t._v("#")]),t._v(" try...catch")]),t._v(" "),s("p",[t._v("try catch中任何给定的异常只会被离它最近的封闭 catch 块捕获一次。如果从finally块中返回一个值，无论是否有return语句在try和catch中，这个值将会成为整个try-catch-finally的返回值。多个try catch嵌套时，先执行最里边的try catch,当嵌套try catch throw 一个新error时，会先运行它自己的finally块再执行外部的catch块")]),t._v(" "),s("h3",{attrs:{id:"export"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#export","aria-hidden":"true"}},[t._v("#")]),t._v(" export")]),t._v(" "),s("p",[t._v("export与import必须处于模块顶层，import具有提升效果，导入多个相同模块时，其实相当于只导入一个，用*可以导出所有模块的输出值，加载出来的模块不可修改")]),t._v(" "),s("h3",{attrs:{id:"class"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class","aria-hidden":"true"}},[t._v("#")]),t._v(" class")]),t._v(" "),s("p",[t._v("class不会变量提升")]),t._v(" "),s("h3",{attrs:{id:"var"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#var","aria-hidden":"true"}},[t._v("#")]),t._v(" var")]),t._v(" "),s("ul",[s("li",[t._v("通过var创建的全局变量（再任何函数体之外创建的变量）不能被删除。")]),t._v(" "),s("li",[t._v("没有用var创建的隐式全局变量（不考虑函数内的情况）可以被删除。")])]),t._v(" "),s("blockquote",[s("p",[t._v("在浏览器环境中，所有js代码都是在"),s("code",[t._v("window")]),t._v("作用域内的，所以在这种情况下，我们所说的全局变量其实都是"),s("code",[t._v("window")]),t._v("下的一个属性， 所以可以用"),s("code",[t._v("delete")]),t._v("删除，但在如\n"),s("code",[t._v("nodejs")]),t._v("或"),s("code",[t._v("gjs")]),t._v("等非浏览器环境下，显示生命的全局变量无法用"),s("code",[t._v("delete")]),t._v("删除")])]),t._v(" "),s("h3",{attrs:{id:"变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#变量","aria-hidden":"true"}},[t._v("#")]),t._v(" 变量")]),t._v(" "),s("h3",{attrs:{id:"async和await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async和await","aria-hidden":"true"}},[t._v("#")]),t._v(" async和await")]),t._v(" "),s("h2",{attrs:{id:"表达式和运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#表达式和运算符","aria-hidden":"true"}},[t._v("#")]),t._v(" 表达式和运算符")]),t._v(" "),s("h3",{attrs:{id:"spread-syntax"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#spread-syntax","aria-hidden":"true"}},[t._v("#")]),t._v(" Spread syntax")]),t._v(" "),s("ul",[s("li",[t._v("展开语法（...）内部使用for...of循环")]),t._v(" "),s("li",[t._v("可以通过扩展运算符将具有Iterator接口的arrlike转换成array,Array.from()可以将带有length属性的对象转换成array，相较与前者少了Iterator的限制。 ​​​​")])]),t._v(" "),s("h3",{attrs:{id:"按位操作符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#按位操作符","aria-hidden":"true"}},[t._v("#")]),t._v(" 按位操作符")]),t._v(" "),s("ol",[s("li",[t._v("非位运算符~，简单的理解，对任一数值 x 进行按位非操作的结果为 -(x + 1)，那么, ~~x就为 -(-(x+1) + 1)。判断数值中是否有某元素时，以前这样判断：")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("indexOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ele"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//易读")]),t._v("\n")])])]),s("p",[t._v("现在可以这样判断：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("indexOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ele"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//简洁")]),t._v("\n")])])]),s("p",[t._v("对于浮点数，~~value可以代替parseInt(value)，而且前者效率更高些")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parseInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.99")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//-2")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.99")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//-2")]),t._v("\n")])])]),s("h2",{attrs:{id:"函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数","aria-hidden":"true"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),s("h2",{attrs:{id:"继承和原型链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#继承和原型链","aria-hidden":"true"}},[t._v("#")]),t._v(" 继承和原型链")]),t._v(" "),s("h3",{attrs:{id:"原型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型","aria-hidden":"true"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),s("p",[t._v("原型是一个普通的对象，你所创建的每一个函数会自动带有"),s("code",[t._v("prototype")]),t._v("属性，这个属性指向一个空对象，这个空对象包含一个"),s("code",[t._v("constructor")]),t._v("属性，它指向你新建的函数而不是内置的"),s("code",[t._v("Object()")]),t._v("。")]),t._v(" "),s("ol",[s("li",[t._v("prototype\n"),s("ol",[s("li",[t._v("构造函数的"),s("code",[t._v("prototype")]),t._v("等于实例对象的"),s("code",[t._v("proto")]),t._v(",指向的就是原型对象")]),t._v(" "),s("li",[t._v("prototype只有函数才有")])])]),t._v(" "),s("li",[t._v("proto\n"),s("ol",[s("li",[t._v("一个对象的"),s("code",[t._v("__proto__")]),t._v("总是指向它的构造函数的prototype")]),t._v(" "),s("li",[s("code",[t._v("Object.prototype.__proto__===null")]),t._v(",继承链的终点等于"),s("code",[t._v("null")])])])]),t._v(" "),s("li",[t._v("constructor\n"),s("ol",[s("li",[t._v("原型对象的"),s("code",[t._v("constructor")]),t._v("指向构造函数")])])])]),t._v(" "),s("p",[t._v("用一张图来汇总他们之间的关系：\n"),s("img",{attrs:{src:"https://blog-pic.oss-cn-beijing.aliyuncs.com/JavaScript%E4%B9%8B%E6%97%85_2020-3-3-8-47-54.png",alt:"JavaScript之旅_2020-3-3-8-47-54.png"}})]),t._v(" "),s("blockquote",[s("p",[t._v("引用："),s("a",{attrs:{href:"https://www.jianshu.com/p/7d58f8f45557",target:"_blank",rel:"noopener noreferrer"}},[t._v("一篇文章看懂_proto_和prototype的关系及区别"),s("OutboundLink")],1)])]),t._v(" "),s("h3",{attrs:{id:"new"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new","aria-hidden":"true"}},[t._v("#")]),t._v(" new")]),t._v(" "),s("p",[t._v("内建对象函数都可以在前面加上 new 来被调用，这使函数调用成为一个 构造器调用（constructor call）。这是一个重要而微妙的区别：实际上不存在“构造器函数”这样的东西，而只有函数的构造器调用。")]),t._v(" "),s("p",[t._v("new 的原理很简单, 就是引擎内部新建一个空对象，然后将这个空对象的proto 指向构造函数的prototype.然后调用构造函数，去填充我们创建的空对象(如果有必要)。 最后将this指向我们刚刚创建的新对象。")]),t._v(" "),s("p",[t._v("如果用代码来表示，大概是这样的：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("myNew")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("constructor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" constructor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ret "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" ret "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" ret "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v("引用:"),s("a",{attrs:{href:"https://lucifer.ren/fe-interview/#/topics/js/prototype?id=new",target:"_blank",rel:"noopener noreferrer"}},[t._v("大前端面试宝典 - 图解前端"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),s("h3",{attrs:{id:"数字转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数字转换","aria-hidden":"true"}},[t._v("#")]),t._v(" 数字转换")]),t._v(" "),s("ol",[s("li",[t._v('parseInt("08")')]),t._v(" "),s("li",[t._v("+'08'")]),t._v(" "),s("li",[t._v("Number('08')")])]),t._v(" "),s("blockquote",[s("p",[t._v("速度:1<2和3")])]),t._v(" "),s("h2",{attrs:{id:"最佳实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践","aria-hidden":"true"}},[t._v("#")]),t._v(" 最佳实践")]),t._v(" "),s("h3",{attrs:{id:"转换数字为整数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#转换数字为整数","aria-hidden":"true"}},[t._v("#")]),t._v(" 转换数字为整数")]),t._v(" "),s("p",[t._v("使用非位运算符可以代替parseInt(value)，而且前者效率更高些")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("～～")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.15")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2")]),t._v("\n")])])]),s("h3",{attrs:{id:"export-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#export-2","aria-hidden":"true"}},[t._v("#")]),t._v(" export")]),t._v(" "),s("p",[t._v("ES6编程风格：如果模块默认输出一个函数，函数名的首字母应该小写。如果模块默认输出一个对象，对象名的首字母应该大写。 ​​​​")]),t._v(" "),s("h2",{attrs:{id:"问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),s("h3",{attrs:{id:"es6-class-组合优先于继承-什么时候使用继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-class-组合优先于继承-什么时候使用继承","aria-hidden":"true"}},[t._v("#")]),t._v(" ES6 class 组合优先于继承,什么时候使用继承?")]),t._v(" "),s("ol",[s("li",[t._v('你的继承表示"是一个"的关系而不是"有一个"的关系（人类->动物 vs 用户->用户详情）；')]),t._v(" "),s("li",[t._v("你可以重用来自基类的代码（人可以像所有动物一样行动）；")]),t._v(" "),s("li",[t._v("你想通过基类对子类进行全局的修改（改变所有动物行动时的热量消耗）；")])]),t._v(" "),s("blockquote",[s("p",[t._v("参考："),s("a",{attrs:{href:"https://github.com/beginor/clean-code-javascript#%E7%BB%84%E5%90%88%E4%BC%98%E5%85%88%E4%BA%8E%E7%BB%A7%E6%89%BF",target:"_blank",rel:"noopener noreferrer"}},[t._v("代码整洁的 JavaScript"),s("OutboundLink")],1)])]),t._v(" "),s("h3",{attrs:{id:"怎么侦测当前代码是否在es6模块之中？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么侦测当前代码是否在es6模块之中？","aria-hidden":"true"}},[t._v("#")]),t._v(" 怎么侦测当前代码是否在es6模块之中？")]),t._v(" "),s("p",[t._v("ES6模块中顶层的this值为undefined，利用这个语法点可以侦测当前代码是否在ES6模块之中。")]),t._v(" "),s("h3",{attrs:{id:"js内存泄漏的几种原因？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js内存泄漏的几种原因？","aria-hidden":"true"}},[t._v("#")]),t._v(" js内存泄漏的几种原因？")]),t._v(" "),s("p",[t._v("js可能出现内存泄漏的五种原因：闭包函数、全局变量、对象属性循环引用、DOM节点删除时未解绑事件、Map和Set的属性直接被删除。 ​​​​")]),t._v(" "),s("h3",{attrs:{id:"为什么-2017-01-01-2016-12-31-？字符串是怎么进行比较的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么-2017-01-01-2016-12-31-？字符串是怎么进行比较的？","aria-hidden":"true"}},[t._v("#")]),t._v(' 为什么"2017-01-01">"2016-12-31"？字符串是怎么进行比较的？')]),t._v(" "),s("p",[t._v('其实是按每个字符的 charCode 大小逐个进行比较。例如："a11"<"a2"为true。 ​​​​')])])},[],!1,null,null,null);a.default=e.exports}}]);