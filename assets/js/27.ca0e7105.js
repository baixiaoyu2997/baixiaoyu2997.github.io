(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{449:function(t,a,e){"use strict";e.r(a);var s=e(2),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"node特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node特点"}},[t._v("#")]),t._v(" Node特点")]),t._v(" "),e("h3",{attrs:{id:"_1-异步i-o"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-异步i-o"}},[t._v("#")]),t._v(" 1.异步I/O")]),t._v(" "),e("h3",{attrs:{id:"_2-事件与回掉函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-事件与回掉函数"}},[t._v("#")]),t._v(" 2.事件与回掉函数")]),t._v(" "),e("h3",{attrs:{id:"_3-单线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-单线程"}},[t._v("#")]),t._v(" 3.单线程")]),t._v(" "),e("p",[t._v("单线程的缺点：")]),t._v(" "),e("ul",[e("li",[t._v("无法利用多核处理器")]),t._v(" "),e("li",[t._v("错误会引起整个应用退出，应用的健壮性值得考验")]),t._v(" "),e("li",[t._v("大量计算占用cpu导致无法继续调用异步I/O")])]),t._v(" "),e("h3",{attrs:{id:"_4-跨平台"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-跨平台"}},[t._v("#")]),t._v(" 4.跨平台")]),t._v(" "),e("ul",[e("li",[t._v("操作系统与Node上层模块系统之间构建了一层平台层架构，即libuv")]),t._v(" "),e("li",[t._v("混合应用")])]),t._v(" "),e("h3",{attrs:{id:"_5-低资源占用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-低资源占用"}},[t._v("#")]),t._v(" 5.低资源占用")]),t._v(" "),e("ul",[e("li",[t._v("适合做云平台开发")])]),t._v(" "),e("h3",{attrs:{id:"_6-前端赋能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-前端赋能"}},[t._v("#")]),t._v(" 6.前端赋能")]),t._v(" "),e("ul",[e("li",[t._v("serverless")]),t._v(" "),e("li",[t._v("工具编写")]),t._v(" "),e("li",[t._v("桌面图形界面应用程序")])]),t._v(" "),e("h2",{attrs:{id:"node应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node应用场景"}},[t._v("#")]),t._v(" Node应用场景")]),t._v(" "),e("h3",{attrs:{id:"_1-i-o密集型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-i-o密集型"}},[t._v("#")]),t._v(" 1.I/O密集型")]),t._v(" "),e("p",[t._v("适合IO密集型，是因为js天生的异步写法，并不是比其他语言优秀，也因为node刚出的时候java对异步支持不是很好。")]),t._v(" "),e("h3",{attrs:{id:"_2-不擅长cpu密集型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-不擅长cpu密集型"}},[t._v("#")]),t._v(" 2.不擅长CPU密集型")]),t._v(" "),e("h3",{attrs:{id:"_3-与一流系统和平共处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-与一流系统和平共处"}},[t._v("#")]),t._v(" 3.与一流系统和平共处")]),t._v(" "),e("h3",{attrs:{id:"_4-分布式应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-分布式应用"}},[t._v("#")]),t._v(" 4.分布式应用")]),t._v(" "),e("h2",{attrs:{id:"file-system"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#file-system"}},[t._v("#")]),t._v(" File System")]),t._v(" "),e("h3",{attrs:{id:"fs-mkdirsync-path-options"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fs-mkdirsync-path-options"}},[t._v("#")]),t._v(" fs.mkdirSync(path[, options])")]),t._v(" "),e("p",[t._v("同步地创建目录。 返回 undefined，或创建的第一个目录的路径（如果 recursive 为 true）。 这是 fs.mkdir() 的同步版本。")]),t._v(" "),e("h3",{attrs:{id:"fs-writefilesync-file-data-options"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fs-writefilesync-file-data-options"}},[t._v("#")]),t._v(" fs.writeFileSync(file, data[, options])")]),t._v(" "),e("p",[t._v("当 file 是文件名时，则异步地写入数据到文件（如果文件已存在，则覆盖文件）。 data 可以是字符串或 buffer。")]),t._v(" "),e("p",[t._v("当 file 是文件描述符时，则其行为类似于直接调用 fs.write()（建议使用）。 参见以下关于使用文件描述符的说明。")]),t._v(" "),e("p",[t._v("如果 data 是 buffer，则 encoding 选项会被忽略。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const data = new Uint8Array(Buffer.from('Node.js 中文网'));\nfs.writeFile('文件.txt', data, (err) => {\n  if (err) throw err;\n  console.log('文件已被保存');\n});\n")])])]),e("p",[t._v("返回 undefined。")]),t._v(" "),e("h2",{attrs:{id:"path"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path"}},[t._v("#")]),t._v(" Path")]),t._v(" "),e("h3",{attrs:{id:"path-join-paths"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#path-join-paths"}},[t._v("#")]),t._v(" path.join([...paths])")]),t._v(" "),e("p",[t._v("path.join() 方法使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。\n零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 '.'，表示当前工作目录。")]),t._v(" "),e("h2",{attrs:{id:"process-进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#process-进程"}},[t._v("#")]),t._v(" process(进程)")]),t._v(" "),e("p",[e("code",[t._v("process")]),t._v(" 对象是一个全局变量，提供了有关当前 "),e("code",[t._v("Node.js")]),t._v(" 进程的信息并对其进行控制。 作为全局变量，它始终可供 "),e("code",[t._v("Node.js")]),t._v(" 应用程序使用，无需使用 "),e("code",[t._v("require()")]),t._v("。 它也可以使用"),e("code",[t._v("require()")]),t._v(" 显式地访问：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" process "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'process'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("h3",{attrs:{id:"process-argv"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#process-argv"}},[t._v("#")]),t._v(" process.argv")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("<string[]>")])])]),t._v(" "),e("p",[e("code",[t._v("process.argv")]),t._v(" 属性会返回一个数组，其中包含当 "),e("code",[t._v("Node.js")]),t._v(" 进程被启动时传入的命令行参数。 第一个元素是 "),e("code",[t._v("process.execPath")]),t._v("。 第二个元素是正被执行的 "),e("code",[t._v("JavaScript")]),t._v(" 文件的路径。 其余的元素是任何额外的命令行参数。所有参数都为字符串")]),t._v(" "),e("h2",{attrs:{id:"问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),e("h3",{attrs:{id:"node中启用import"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node中启用import"}},[t._v("#")]),t._v(" node中启用import？")]),t._v(" "),e("blockquote",[e("p",[t._v("前置条件: "),e("code",[t._v("node")]),t._v("命令后添加"),e("code",[t._v("--experimental-modules")]),t._v("参数，例如："),e("code",[t._v("node --experimental-modules test.js")])])]),t._v(" "),e("p",[t._v("在"),e("code",[t._v("node v12")]),t._v("中有三种方法：")]),t._v(" "),e("ol",[e("li",[t._v("文件以"),e("code",[t._v(".ejs")]),t._v("结尾")]),t._v(" "),e("li",[t._v("最近的"),e("code",[t._v("package.json")]),t._v("中添加"),e("code",[t._v("'type':'module'")])]),t._v(" "),e("li",[t._v("Strings passed in as an argument to --eval or --print, or piped to node via STDIN, with the flag --input-type=module.")])]),t._v(" "),e("p",[t._v("我使用的是第二种方法")]),t._v(" "),e("h3",{attrs:{id:"当type-module-时-就不能再使用require"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#当type-module-时-就不能再使用require"}},[t._v("#")]),t._v(" 当type=‘module’时，就不能再使用require？")]),t._v(" "),e("p",[t._v("可以使用 module.createRequire()替代，更多关于ES Modules 和 CommonJS的用法区别，可以查看：https://nodejs.org/api/esm.html#esm_differences_between_es_modules_and_commonjs")])])}),[],!1,null,null,null);a.default=r.exports}}]);