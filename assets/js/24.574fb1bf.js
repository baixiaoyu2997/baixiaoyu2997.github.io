(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{455:function(t,e,a){"use strict";a.r(e);var s=a(2),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),a("p",[t._v("Jest是facebook出品的单元测试框架, 请记住，测试是输入，功能和预期输出的问题")]),t._v(" "),a("p",[t._v("默认会去"),a("code",[t._v("__test__")]),t._v("中查找测试文件。")]),t._v(" "),a("p",[t._v("一个测试文件中至少要有一个"),a("code",[t._v("test")]),t._v("函数")]),t._v(" "),a("h3",{attrs:{id:"执行顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行顺序"}},[t._v("#")]),t._v(" 执行顺序")]),t._v(" "),a("p",[t._v("先执行最外层的"),a("code",[t._v("describe")]),t._v("，然后是里层的"),a("code",[t._v("it")]),t._v(", 异步"),a("code",[t._v("it")]),t._v("会阻塞后边所有"),a("code",[t._v("describe")]),t._v("中的"),a("code",[t._v("it")]),t._v("块执行")]),t._v(" "),a("h2",{attrs:{id:"esm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#esm"}},[t._v("#")]),t._v(" ESM")]),t._v(" "),a("p",[t._v("首先需要设置package.json中type=module")]),t._v(" "),a("h3",{attrs:{id:"yarn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#yarn"}},[t._v("#")]),t._v(" yarn")]),t._v(" "),a("p",[t._v("使用yarn，需要运行指令"),a("code",[t._v("yarn node --experimental-vm-modules $(yarn bin jest)")]),t._v("替代"),a("code",[t._v("test")])]),t._v(" "),a("h2",{attrs:{id:"快照测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快照测试"}},[t._v("#")]),t._v(" 快照测试")]),t._v(" "),a("p",[t._v("使用snapshot可以保存ui组件的快照，如果两个快照不匹配则报错，如果是修改了组件，则需要更新快照文件，"),a("code",[t._v("jest -u")]),t._v(",这个指令会更新所有快照。")]),t._v(" "),a("p",[t._v("如果想限制只重新生成一部分快照，则使用"),a("code",[t._v("-testNamePattern")]),t._v("来生成匹配想要生成的快照名字")]),t._v(" "),a("h3",{attrs:{id:"交互式快照模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#交互式快照模式"}},[t._v("#")]),t._v(" 交互式快照模式")]),t._v(" "),a("p",[t._v("进入交互模式后，失败的快照可以从命令行选择更新，使用指令"),a("code",[t._v("--watch")])]),t._v(" "),a("h3",{attrs:{id:"属性匹配器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性匹配器"}},[t._v("#")]),t._v(" 属性匹配器")]),t._v(" "),a("p",[t._v("当存在动态属性时，则每次快照都会失败，Jest提供了非对称匹配器，在测试检查时，只判断知否满足某些条件，而不是具体的值：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('it(\'will check the matchers and pass\', () => {\n  const user = {\n    createdAt: new Date(),\n    id: Math.floor(Math.random() * 20),\n    name: \'LeBron James\',\n  };\n\n  expect(user).toMatchSnapshot({\n    createdAt: expect.any(Date), // 对于动态值，只判断是否满足条件\n    id: expect.any(Number),      \n  });\n});\n\n// Snapshot\nexports[`will check the matchers and pass 1`] = `\nObject {\n  "createdAt": Any<Date>,        // 生成的快照中，值为特定类型\n  "id": Any<Number>,\n  "name": "LeBron James",\n}\n`;\n')])])]),a("h3",{attrs:{id:"最佳实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[t._v("#")]),t._v(" 最佳实践")]),t._v(" "),a("ol",[a("li",[t._v("应该提交快照，并且使用prettier或者eslint等工具进行校验格式化")]),t._v(" "),a("li",[t._v("测试应该是确定性的，尽量减少随机的东西，比如"),a("code",[t._v("Date.now")]),t._v("的数据，我们可以通过"),a("code",[t._v("mock Date.now")]),t._v("重写该方法，来返回确定值。"),a("code",[t._v("Date.now = jest.fn(() => 1482363367071);")])]),t._v(" "),a("li",[t._v("合理的快照描述， 最好的描述名称是写出期望的返回内容。")])]),t._v(" "),a("h2",{attrs:{id:"globals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#globals"}},[t._v("#")]),t._v(" Globals")]),t._v(" "),a("h3",{attrs:{id:"describe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#describe"}},[t._v("#")]),t._v(" describe")]),t._v(" "),a("p",[t._v("相当于一个块，describe(name, fn) 创建一个将几个相关测试组合在一起的块。describe中可以写钩子函数，比如"),a("code",[t._v("beforeAll、beforeEach")]),t._v(".执行顺序，是块中的代码最先执行，然后才是钩子函数")]),t._v(" "),a("h3",{attrs:{id:"test"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test"}},[t._v("#")]),t._v(" test")]),t._v(" "),a("blockquote",[a("p",[t._v("还有一个假名叫 it(name,fn,timeout)")])]),t._v(" "),a("p",[t._v("真正运行测试的函数，如果测试函数为promise，则应"),a("code",[t._v("return")]),t._v("返回")]),t._v(" "),a("h3",{attrs:{id:"beforeall"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforeall"}},[t._v("#")]),t._v(" beforeAll")]),t._v(" "),a("p",[t._v("在所有测试之前运行，相当于初始化,执行顺序早于"),a("code",[t._v("beforeEach")])]),t._v(" "),a("h3",{attrs:{id:"afterall"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#afterall"}},[t._v("#")]),t._v(" afterAll")]),t._v(" "),a("p",[t._v("在所有测试之后运行,执行顺序晚于"),a("code",[t._v("afterEach")])]),t._v(" "),a("h3",{attrs:{id:"beforeeach"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforeeach"}},[t._v("#")]),t._v(" beforeEach")]),t._v(" "),a("p",[t._v("每个"),a("code",[t._v("test")]),t._v("运行前都会运行该函数")]),t._v(" "),a("h2",{attrs:{id:"expect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expect"}},[t._v("#")]),t._v(" Expect")]),t._v(" "),a("p",[t._v("在编写测试时，您经常需要检查值是否满足某些条件。")]),t._v(" "),a("h3",{attrs:{id:"expect-value"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expect-value"}},[t._v("#")]),t._v(" expect(value)")]),t._v(" "),a("p",[t._v("expect 使您可以访问许多“匹配器”，使你可以验证不同的事物。")]),t._v(" "),a("h3",{attrs:{id:"assertions-number"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#assertions-number"}},[t._v("#")]),t._v(" assertions(number)")]),t._v(" "),a("p",[t._v("确定一个test中，调用了几次断言，这通常在异步函数中很有用")]),t._v(" "),a("h3",{attrs:{id:"toequal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#toequal"}},[t._v("#")]),t._v(" .toEqual()")]),t._v(" "),a("p",[t._v("判断是否相等，使用"),a("code",[t._v("Object.is")])]),t._v(" "),a("h2",{attrs:{id:"the-jest-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-jest-object"}},[t._v("#")]),t._v(" The Jest Object")]),t._v(" "),a("h3",{attrs:{id:"mock-modules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mock-modules"}},[t._v("#")]),t._v(" Mock Modules")]),t._v(" "),a("h4",{attrs:{id:"jest-mock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jest-mock"}},[t._v("#")]),t._v(" jest.mock")]),t._v(" "),a("p",[t._v("通过mock来模仿无法在node端执行的操作")]),t._v(" "),a("h2",{attrs:{id:"configuring-jest"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#configuring-jest"}},[t._v("#")]),t._v(" Configuring Jest")]),t._v(" "),a("h3",{attrs:{id:"testtimeout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#testtimeout"}},[t._v("#")]),t._v(" testTimeout")]),t._v(" "),a("p",[t._v("默认异步测试会在超时5秒后结束，对于可能需要等待更长时间的测试需要修改此项")]),t._v(" "),a("h2",{attrs:{id:"jest-cli-options"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jest-cli-options"}},[t._v("#")]),t._v(" Jest CLI Options")]),t._v(" "),a("h3",{attrs:{id:"coverage-boolean"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coverage-boolean"}},[t._v("#")]),t._v(" "),a("code",[t._v("--coverage[=<boolean>]")])]),t._v(" "),a("p",[t._v("为测试代码添加代码覆盖率输出，代码覆盖率指是否测试函数中所有条件语句都走到了，如果要始终开启需要配置"),a("code",[t._v("package.json")]),t._v(":")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('"scripts": {\n    "test": "jest"\n  },\n  "jest": {\n    "collectCoverage": true,\n    ""coverageReporters": ["html"]" //如果想生成html报告设置该项\n  },\n\n')])])]),a("h3",{attrs:{id:"bail"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bail"}},[t._v("#")]),t._v(" --bail")]),t._v(" "),a("p",[t._v("别名："),a("code",[t._v("-b")]),t._v("。在 n 个测试套件失败后立即退出测试套件。默认为 1。")]),t._v(" "),a("h2",{attrs:{id:"最佳实践-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践-2"}},[t._v("#")]),t._v(" 最佳实践")]),t._v(" "),a("ol",[a("li",[t._v("为了保证代码执行顺序，建议测试代码都写在钩子函数或者测试用例中")])]),t._v(" "),a("h2",{attrs:{id:"问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),a("h3",{attrs:{id:"如何单独指定一个文件运行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何单独指定一个文件运行"}},[t._v("#")]),t._v(" 如何单独指定一个文件运行？")]),t._v(" "),a("p",[t._v("只需要在test指令后添加测试文件名称即可，不需要全路径，jest会自动匹配。比如"),a("code",[t._v("npm test other.test.js")])])])}),[],!1,null,null,null);e.default=r.exports}}]);