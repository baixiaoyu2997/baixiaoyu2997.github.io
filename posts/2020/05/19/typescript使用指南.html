<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TypeScript使用指南 | L.Rain的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <meta name="description" content="L.Rain的博客">
    <link rel="preload" href="/assets/css/0.styles.0b94e76f.css" as="style"><link rel="preload" href="/assets/js/app.f3f948e5.js" as="script"><link rel="preload" href="/assets/js/7.8545d9f8.js" as="script"><link rel="preload" href="/assets/js/46.bd48e39f.js" as="script"><link rel="prefetch" href="/assets/js/1.f6e0f07f.js"><link rel="prefetch" href="/assets/js/10.4a6afb4e.js"><link rel="prefetch" href="/assets/js/100.00690d66.js"><link rel="prefetch" href="/assets/js/101.b03e7e78.js"><link rel="prefetch" href="/assets/js/102.65326722.js"><link rel="prefetch" href="/assets/js/103.d406d78e.js"><link rel="prefetch" href="/assets/js/104.6a1f86e2.js"><link rel="prefetch" href="/assets/js/105.0f31792b.js"><link rel="prefetch" href="/assets/js/106.6c9ad918.js"><link rel="prefetch" href="/assets/js/107.ee598287.js"><link rel="prefetch" href="/assets/js/108.b5fb77fe.js"><link rel="prefetch" href="/assets/js/109.b2439d14.js"><link rel="prefetch" href="/assets/js/11.d13437d4.js"><link rel="prefetch" href="/assets/js/110.0d63ca3f.js"><link rel="prefetch" href="/assets/js/111.2c66addd.js"><link rel="prefetch" href="/assets/js/112.d6da0f6e.js"><link rel="prefetch" href="/assets/js/113.87534de5.js"><link rel="prefetch" href="/assets/js/114.9d1d8fa1.js"><link rel="prefetch" href="/assets/js/115.ff10b6f6.js"><link rel="prefetch" href="/assets/js/116.e20742ae.js"><link rel="prefetch" href="/assets/js/117.e7d8d1af.js"><link rel="prefetch" href="/assets/js/118.8ea36d1a.js"><link rel="prefetch" href="/assets/js/119.92e02005.js"><link rel="prefetch" href="/assets/js/12.7d7635cb.js"><link rel="prefetch" href="/assets/js/120.c1d798df.js"><link rel="prefetch" href="/assets/js/121.a3eb223d.js"><link rel="prefetch" href="/assets/js/13.919964bf.js"><link rel="prefetch" href="/assets/js/14.5ff823ae.js"><link rel="prefetch" href="/assets/js/15.99e9e2eb.js"><link rel="prefetch" href="/assets/js/16.cf847976.js"><link rel="prefetch" href="/assets/js/17.68c10889.js"><link rel="prefetch" href="/assets/js/18.12534d82.js"><link rel="prefetch" href="/assets/js/19.3c94f51e.js"><link rel="prefetch" href="/assets/js/20.1bd9be68.js"><link rel="prefetch" href="/assets/js/21.28d796df.js"><link rel="prefetch" href="/assets/js/22.bfdfc41c.js"><link rel="prefetch" href="/assets/js/23.2a062f7f.js"><link rel="prefetch" href="/assets/js/24.e18c817e.js"><link rel="prefetch" href="/assets/js/25.722a033a.js"><link rel="prefetch" href="/assets/js/26.01e9d959.js"><link rel="prefetch" href="/assets/js/27.4b7fbb8c.js"><link rel="prefetch" href="/assets/js/28.5f5c310e.js"><link rel="prefetch" href="/assets/js/29.463b5d28.js"><link rel="prefetch" href="/assets/js/3.abcd40dc.js"><link rel="prefetch" href="/assets/js/30.d09f9f0a.js"><link rel="prefetch" href="/assets/js/31.b9416bd5.js"><link rel="prefetch" href="/assets/js/32.d180d63d.js"><link rel="prefetch" href="/assets/js/33.2b4d3a05.js"><link rel="prefetch" href="/assets/js/34.641090b9.js"><link rel="prefetch" href="/assets/js/35.d50ed1d6.js"><link rel="prefetch" href="/assets/js/36.2d2c0cbe.js"><link rel="prefetch" href="/assets/js/37.1426b4d7.js"><link rel="prefetch" href="/assets/js/38.0792bcd9.js"><link rel="prefetch" href="/assets/js/39.ee9f93e7.js"><link rel="prefetch" href="/assets/js/4.037891d1.js"><link rel="prefetch" href="/assets/js/40.4965c53c.js"><link rel="prefetch" href="/assets/js/41.dd9117e7.js"><link rel="prefetch" href="/assets/js/42.05ea98be.js"><link rel="prefetch" href="/assets/js/43.b28e38da.js"><link rel="prefetch" href="/assets/js/44.7fc33c3f.js"><link rel="prefetch" href="/assets/js/45.5eaf4dc1.js"><link rel="prefetch" href="/assets/js/47.1406a8e4.js"><link rel="prefetch" href="/assets/js/48.680b3167.js"><link rel="prefetch" href="/assets/js/49.5d634f35.js"><link rel="prefetch" href="/assets/js/5.023c6154.js"><link rel="prefetch" href="/assets/js/50.c9d5c85b.js"><link rel="prefetch" href="/assets/js/51.3b049ffa.js"><link rel="prefetch" href="/assets/js/52.f6891e69.js"><link rel="prefetch" href="/assets/js/53.4aa54af0.js"><link rel="prefetch" href="/assets/js/54.6a9e6d10.js"><link rel="prefetch" href="/assets/js/55.8bbe2a85.js"><link rel="prefetch" href="/assets/js/56.a85b7d61.js"><link rel="prefetch" href="/assets/js/57.b595c295.js"><link rel="prefetch" href="/assets/js/58.57df37bd.js"><link rel="prefetch" href="/assets/js/59.7b090e92.js"><link rel="prefetch" href="/assets/js/6.118b5a7a.js"><link rel="prefetch" href="/assets/js/60.4d81b83e.js"><link rel="prefetch" href="/assets/js/61.2ebaff37.js"><link rel="prefetch" href="/assets/js/62.79af8aa9.js"><link rel="prefetch" href="/assets/js/63.b8fe69a6.js"><link rel="prefetch" href="/assets/js/64.f04f617d.js"><link rel="prefetch" href="/assets/js/65.a90b10c6.js"><link rel="prefetch" href="/assets/js/66.9e701cff.js"><link rel="prefetch" href="/assets/js/67.69accf88.js"><link rel="prefetch" href="/assets/js/68.02005b54.js"><link rel="prefetch" href="/assets/js/69.caca86d2.js"><link rel="prefetch" href="/assets/js/70.2aa39324.js"><link rel="prefetch" href="/assets/js/71.813d9785.js"><link rel="prefetch" href="/assets/js/72.feb39ddf.js"><link rel="prefetch" href="/assets/js/73.4166c05e.js"><link rel="prefetch" href="/assets/js/74.15141838.js"><link rel="prefetch" href="/assets/js/75.73494c15.js"><link rel="prefetch" href="/assets/js/76.85b76b27.js"><link rel="prefetch" href="/assets/js/77.d6bf62ba.js"><link rel="prefetch" href="/assets/js/78.49c87c7c.js"><link rel="prefetch" href="/assets/js/79.ec76b1f5.js"><link rel="prefetch" href="/assets/js/8.51c6e2dd.js"><link rel="prefetch" href="/assets/js/80.58b89a63.js"><link rel="prefetch" href="/assets/js/81.6ec4c951.js"><link rel="prefetch" href="/assets/js/82.9a316b1b.js"><link rel="prefetch" href="/assets/js/83.b62a35e8.js"><link rel="prefetch" href="/assets/js/84.81879853.js"><link rel="prefetch" href="/assets/js/85.96a2fd73.js"><link rel="prefetch" href="/assets/js/86.a9cf33e0.js"><link rel="prefetch" href="/assets/js/87.8eb3ec20.js"><link rel="prefetch" href="/assets/js/88.318384bb.js"><link rel="prefetch" href="/assets/js/89.3634cbfa.js"><link rel="prefetch" href="/assets/js/9.50140b23.js"><link rel="prefetch" href="/assets/js/90.0693c763.js"><link rel="prefetch" href="/assets/js/91.c8dbc323.js"><link rel="prefetch" href="/assets/js/92.9288651a.js"><link rel="prefetch" href="/assets/js/93.7488f678.js"><link rel="prefetch" href="/assets/js/94.c84bd54c.js"><link rel="prefetch" href="/assets/js/95.903d1a46.js"><link rel="prefetch" href="/assets/js/96.c483a229.js"><link rel="prefetch" href="/assets/js/97.f9d20d24.js"><link rel="prefetch" href="/assets/js/98.cb4974db.js"><link rel="prefetch" href="/assets/js/99.049f174b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0b94e76f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-meteorlxy"><header class="header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(https://picsum.photos/1920/250.webp);" data-v-7a046aea><div data-v-e4145d0a data-v-7a046aea><nav class="navbar" data-v-e4145d0a><div class="container" data-v-e4145d0a><a href="/" class="router-link-active" data-v-e4145d0a><span class="navbar-site-name" data-v-e4145d0a>
          L.Rain的博客
        </span></a> <div class="navbar-toggler" data-v-e4145d0a><svg class="icon" style="font-size:1.2em;" data-v-e4145d0a data-v-e4145d0a><title data-v-e4145d0a data-v-e4145d0a>menu</title><use xlink:href="#icon-menu" data-v-e4145d0a data-v-e4145d0a></use></svg></div> <div class="navbar-links" data-v-e4145d0a><a href="/" class="navbar-link" data-v-e4145d0a>
            主页
          </a><a href="/posts/" class="navbar-link router-link-active" data-v-e4145d0a>
            分类
          </a><a href="https://github.com/baixiaoyu2997" target="_blank" rel="noopener noreferrer" class="navbar-link" data-v-e4145d0a><span data-v-e4145d0a>Github</span> <span data-v-e4145d0a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-e4145d0a></div></div> <div class="banner" data-v-98d6aa8c data-v-7a046aea data-v-7a046aea><div class="container" data-v-98d6aa8c><div class="center" data-v-98d6aa8c><h1 data-v-98d6aa8c data-v-7a046aea>
          TypeScript使用指南
        </h1></div></div></div></header> <div class="container clearfix show-aside" data-v-4dd605a1 data-v-4dd605a1><main class="main" data-v-4dd605a1><div class="post" data-v-4dd605a1 data-v-4dd605a1><section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2020-05-19
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2022-06-11
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2020/05/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html" class="post-link" data-v-4e23451f>
      上一篇 : 前端工程化
    </a> <a href="/posts/2020/05/29/eslint%E6%8C%87%E5%8D%97.html" class="post-link" data-v-4e23451f>
      下一篇 : ESLint指南
    </a></section></section> <article class="main-div"><div class="post-content content content__default"><h2 id="项目配置"><a href="#项目配置" class="header-anchor">#</a> 项目配置</h2> <h3 id="tsconfig-json"><a href="#tsconfig-json" class="header-anchor">#</a> tsconfig.json</h3> <table><thead><tr><th>属性</th> <th>详细</th></tr></thead> <tbody><tr><td>files</td> <td>设置要编译的文件的名称</td></tr> <tr><td>includes</td> <td>设置需要进行编译的文件，支持路径模式匹配；</td></tr> <tr><td>exclude</td> <td>设置无需进行编译的文件，支持路径模式匹配；</td></tr> <tr><td>compilerOptions</td> <td>编译流程相关配置，详情看下边的列表</td></tr></tbody></table> <h3 id="compileoptions"><a href="#compileoptions" class="header-anchor">#</a> compileOptions</h3> <table><thead><tr><th>属性</th> <th>详细</th></tr></thead> <tbody><tr><td>target</td> <td>指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'</td></tr> <tr><td>module</td> <td>指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'</td></tr> <tr><td>lib</td> <td>指定要包含在编译中的库文件</td></tr> <tr><td>allowJs</td> <td>允许编译 javascript 文件</td></tr> <tr><td>checkJs</td> <td>报告 javascript 文件中的错误</td></tr> <tr><td>jsx</td> <td>指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'</td></tr> <tr><td>declaration</td> <td>为ts和js项目生成.d.ts声明文件</td></tr> <tr><td>sourceMap</td> <td>生成相应的 '.map' 文件</td></tr> <tr><td>outFile</td> <td>将输出文件合并为一个文件</td></tr> <tr><td>outDir</td> <td>指定输出目录</td></tr> <tr><td>rootDir</td> <td>用来控制输出目录结构 --outDir.</td></tr> <tr><td>removeComments</td> <td>删除编译后的所有的注释</td></tr> <tr><td>noEmit</td> <td>不生成输出文件</td></tr> <tr><td>importHelpers</td> <td>从 tslib 导入辅助工具函数</td></tr> <tr><td>isolatedModules</td> <td>将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.</td></tr> <tr><td>strict</td> <td>启用所有严格类型检查选项</td></tr> <tr><td>noImplicitAny</td> <td>在表达式和声明上有隐含的 any类型时报错</td></tr> <tr><td>strictNullChecks</td> <td>启用严格的 null 检查</td></tr> <tr><td>noImplicitThis</td> <td>当 this 表达式值为 any 类型的时候，生成一个错误</td></tr> <tr><td>alwaysStrict</td> <td>以严格模式检查每个模块，并在每个文件里加入 'use strict'</td></tr> <tr><td>noUnusedLocals</td> <td>有未使用的变量时，抛出错误</td></tr> <tr><td>noUnusedParameters</td> <td>有未使用的参数时，抛出错误</td></tr> <tr><td>noImplicitReturns</td> <td>并不是所有函数里的代码都有返回值时，抛出错误</td></tr> <tr><td>noFallthroughCasesInSwitch</td> <td>报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</td></tr> <tr><td>moduleResolution</td> <td>选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)</td></tr> <tr><td>baseUrl</td> <td>用于解析非相对模块名称的基目录</td></tr> <tr><td>paths</td> <td>模块名到基于 baseUrl 的路径映射的列表</td></tr> <tr><td>rootDirs</td> <td>根文件夹列表，可以指定多个路径为根目录，甚至是不存在的路径，在导入时非常有帮助</td></tr> <tr><td>typeRoots</td> <td>包含类型声明的文件列表</td></tr> <tr><td>types</td> <td>需要包含的类型声明文件名列表</td></tr> <tr><td>allowSyntheticDefaultImports</td> <td>允许从没有设置默认导出的模块中默认导入。</td></tr> <tr><td>sourceRoot</td> <td>指定调试器应该找到 TypeScript 文件而不是源文件的位置</td></tr> <tr><td>mapRoot</td> <td>指定调试器应该找到映射文件而不是生成文件的位置</td></tr> <tr><td>inlineSourceMap</td> <td>生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</td></tr> <tr><td>inlineSources</td> <td>将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</td></tr> <tr><td>experimentalDecorators</td> <td>启用装饰器</td></tr> <tr><td>emitDecoratorMetadata</td> <td>为装饰器提供元数据的支持</td></tr></tbody></table> <h2 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h2> <h3 id="类型"><a href="#类型" class="header-anchor">#</a> 类型</h3> <p>类型是一个统称，包括<code>interface</code>和<code>type</code>等，类型不能使用<code>test.xxx</code>语法，应该使用<code>test['xxx']</code></p> <h3 id="类型推断"><a href="#类型推断" class="header-anchor">#</a> 类型推断</h3> <p>TypeScript 会根据上下文环境自动推断出变量的类型，无须我们再写明类型注解,比如</p> <div class="language-ts extra-class"><pre class="language-ts"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onmousedown</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>mouseEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mouseEvent<span class="token punctuation">.</span>button<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//&lt;- OK</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mouseEvent<span class="token punctuation">.</span>kangaroo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;- Error!</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这里通过<code>onmousedown</code>函数的类型来推断参数的类型，如果没有上下文归类，则参数为<code>any</code>类型</p> <h3 id="类型守卫"><a href="#类型守卫" class="header-anchor">#</a> 类型守卫</h3> <ol><li>类型判定，一个函数接收类型，并返回一个类型谓词(<code>parameterName is Type</code>),parameterName必须是这个函数的参数</li> <li>in操作符</li> <li>typeof，只支持两种形式<code>typeof v===&quot;xxx&quot;</code>或者<code>typeof !==&quot;xxx&quot;</code></li> <li>instanceof</li></ol> <h3 id="联合类型-union-type"><a href="#联合类型-union-type" class="header-anchor">#</a> 联合类型(union type)</h3> <p>联合类型表示取值可以为多种类型中的一种，使用 <code>|</code> 分隔每个类型。联合类型的扩展直接用<code>|</code>就可以了，例:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Num</span> <span class="token operator">=</span><span class="token number">1</span> <span class="token operator">|</span><span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span>
<span class="token keyword">type</span> <span class="token class-name">Num2</span> <span class="token operator">=</span> Num <span class="token operator">|</span> <span class="token number">4</span>
</code></pre></div><h3 id="类型别名"><a href="#类型别名" class="header-anchor">#</a> 类型别名</h3> <p>类型别名就是type，类型别名不会创造新的类型，只是对其他类型的引用:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Message</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="类型拓宽-type-widening"><a href="#类型拓宽-type-widening" class="header-anchor">#</a> 类型拓宽(Type Widening)</h3> <p>所有通过 let 或 var 定义的变量、函数的形参、对象的非只读属性，如果满足指定了初始值且未显式添加类型注解的条件，那么它们推断出来的类型就是指定的初始值字面量类型拓宽后的类型，这就是字面量类型拓宽。</p> <div class="language-ts extra-class"><pre class="language-ts"><code>  <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'this is string'</span><span class="token punctuation">;</span> <span class="token comment">// 类型是 string</span>
  <span class="token keyword">let</span> strFun <span class="token operator">=</span> <span class="token punctuation">(</span>str <span class="token operator">=</span> <span class="token string">'this is string'</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> str<span class="token punctuation">;</span> <span class="token comment">// 类型是 (str?: string) =&gt; string;</span>
  <span class="token keyword">const</span> specifiedStr <span class="token operator">=</span> <span class="token string">'this is string'</span><span class="token punctuation">;</span> <span class="token comment">// 类型是 'this is string'</span>
  <span class="token keyword">let</span> str2 <span class="token operator">=</span> specifiedStr<span class="token punctuation">;</span> <span class="token comment">// 类型是 'string'</span>
  <span class="token keyword">let</span> <span class="token function-variable function">strFun2</span> <span class="token operator">=</span> <span class="token punctuation">(</span>str <span class="token operator">=</span> specifiedStr<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> str<span class="token punctuation">;</span> <span class="token comment">// 类型是 (str?: string) =&gt; string;</span>
</code></pre></div><p>除了字面量类型，<code>null</code>和<code>undefined</code>也会进行拓宽</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 类型拓宽成 any</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 类型拓宽成 any</span>
</code></pre></div><blockquote><p>在严格模式下，一些比较老的版本中（2.0）null 和 undefined 并不会被拓宽成“any”</p></blockquote> <h3 id="类型缩小-type-narrowing"><a href="#类型缩小-type-narrowing" class="header-anchor">#</a> 类型缩小(Type Narrowing)</h3> <blockquote><p>typescript不支持使用可选链做类型收窄</p></blockquote> <p>通过判断语句可以缩小类型范围比如：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token punctuation">{</span>
  <span class="token keyword">type</span> <span class="token class-name">Goods</span> <span class="token operator">=</span> <span class="token string">'pen'</span> <span class="token operator">|</span> <span class="token string">'pencil'</span> <span class="token punctuation">;</span>
  <span class="token keyword">const</span> getPenCost <span class="token operator">=</span> <span class="token punctuation">(</span>item<span class="token operator">:</span> <span class="token string">'pen'</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 只接收单一类型`pen`</span>
  <span class="token keyword">const</span> <span class="token function-variable function">getCost</span> <span class="token operator">=</span> <span class="token punctuation">(</span>item<span class="token operator">:</span> Goods<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">===</span> <span class="token string">'pen'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 通过语句判断缩小类型范围，所以getPenCost函数不会类型报错</span>
      <span class="token keyword">return</span> <span class="token function">getPenCost</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// item =&gt; 'pen'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不要使用<code>falsy</code>进行判断，可能导致类型拓宽</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">;</span> <span class="token comment">// Type is string | number | null | undefined\</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还有一种常用的缩小类型的方法，就是在他们上放置一个明确的标签，这种模式也被称为 ”标签联合“ 或 ”可辨识联合“：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">UploadEvent</span> <span class="token punctuation">{</span>
  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token string">&quot;upload&quot;</span><span class="token punctuation">;</span>
  filename<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  contents<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">DownloadEvent</span> <span class="token punctuation">{</span>
  <span class="token keyword">type</span><span class="token operator">:</span> <span class="token string">&quot;download&quot;</span><span class="token punctuation">;</span>
  filename<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">AppEvent</span> <span class="token operator">=</span> UploadEvent <span class="token operator">|</span> DownloadEvent<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">handleEvent</span><span class="token punctuation">(</span>e<span class="token operator">:</span> AppEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&quot;download&quot;</span><span class="token operator">:</span>
      e<span class="token punctuation">;</span> <span class="token comment">// Type is DownloadEvent </span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">&quot;upload&quot;</span><span class="token operator">:</span>
      e<span class="token punctuation">;</span> <span class="token comment">// Type is UploadEvent </span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="签名的种类"><a href="#签名的种类" class="header-anchor">#</a> 签名的种类</h3> <ol><li>字符串索引签名</li> <li>数字索引签名</li> <li>调用签名，用来描述接口或者type可被调用</li></ol> <h3 id="ts中的几种符号"><a href="#ts中的几种符号" class="header-anchor">#</a> ts中的几种符号</h3> <h4 id=""><a href="#" class="header-anchor">#</a> []</h4> <p><code>string[]</code>表示数组类型，<code>any[string]</code>表示获取any类型的<code>string</code>索引类型</p> <h4 id="-2"><a href="#-2" class="header-anchor">#</a> &lt;&gt;</h4> <p>一般用于表示泛型，<code>type NameOrId&lt;T extends number | string&gt; = T extends number ? IdLabel: nameLabel;</code></p> <p>还可以表示映射类型</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Num</span> <span class="token operator">=</span> GetReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="everyday-types"><a href="#everyday-types" class="header-anchor">#</a> Everyday Types</h2> <h3 id="any"><a href="#any" class="header-anchor">#</a> any</h3> <p>any类型允许访问变量的任何属性和方法</p> <p>变量定义时如果没有指定类型，不管之后值的类型如何推断该变量的类型都为<code>any</code></p> <h2 id="枚举"><a href="#枚举" class="header-anchor">#</a> 枚举</h2> <p>枚举很特殊，既可以做变量又可以做类型。枚举分为数字枚举和字符串枚举还有常量枚举，数字枚举成员还具有了_反向映射_，枚举可以通过<code>keyof typeof</code>来创建联合类型,例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> Test <span class="token punctuation">{</span>
    a<span class="token punctuation">,</span>
    b<span class="token punctuation">,</span>
    c
<span class="token punctuation">}</span>
type Test2 <span class="token operator">=</span> keyof <span class="token keyword">typeof</span> Test  <span class="token comment">// &quot;a&quot;|&quot;b&quot;|&quot;c&quot;</span>
</code></pre></div><h3 id="常量枚举"><a href="#常量枚举" class="header-anchor">#</a> 常量枚举</h3> <p>使用const定义，不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来</p> <h2 id="class"><a href="#class" class="header-anchor">#</a> Class</h2> <p>限制<code>Class</code>类型的方法，目前已经找到的有<code>implements</code>,通过<code>implements</code>可以限制class的属性类型等</p> <h2 id="functions"><a href="#functions" class="header-anchor">#</a> Functions</h2> <h3 id="函数声明方式"><a href="#函数声明方式" class="header-anchor">#</a> 函数声明方式</h3> <p>有两种方式，一种是：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">LongHand</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">number</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还有一种是内联声明，但是只有第一种方式可以使用重载</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">ShortHand</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
</code></pre></div><p>函数注解还支持箭头函数：<code>const simple: (foo: number) =&gt; string = foo =&gt; foo.toString();</code></p> <p>函数可实例化：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">CallMeWithNewToGetString</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> Foo<span class="token operator">:</span> CallMeWithNewToGetString<span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bar 被推断为 string 类型</span>
</code></pre></div><h3 id="overloads-重载"><a href="#overloads-重载" class="header-anchor">#</a> Overloads(重载)</h3> <p>当函数参数有多个类型值和多个类型的返回值时，需要使用重载来声明对应的各个类型,</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Number</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p> <p>解决了什么问题？如果合并参数类型的话，那么最终函数返回值类型不是固定的，也就有可能会导致不存在某类型方法，比如<code>split</code>等</p> <h3 id="可选参数"><a href="#可选参数" class="header-anchor">#</a> 可选参数</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">?</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果为函数参数提供默认值，则推断其为可选参数,此时就不受「可选参数必须接在必需参数后面」的限制了：</p> <h3 id="剩余参数"><a href="#剩余参数" class="header-anchor">#</a> 剩余参数</h3> <p>ts中剩余参数不会自动推断出类型，隐式类型为<code>any[]</code></p> <div class="language- extra-class"><pre class="language-text"><code>type a=(...args)=&gt;any  // args的类型为any[]
</code></pre></div><p>通过将回调函数作为类型变量传入泛型，为回调函数添加参数类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> useTest <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>cb<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    cb<span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> cb <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useTest</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">typeof</span> callback<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
<span class="token function">cb</span><span class="token punctuation">(</span><span class="token string">'nihao'</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="扩展参数"><a href="#扩展参数" class="header-anchor">#</a> 扩展参数</h3> <p>假如定义了一个函数</p> <div class="language- extra-class"><pre class="language-text"><code>function test(a:number,b:string){
	return a+b
}
</code></pre></div><p>直接调用<code>test(...[1,'2'])</code>是不可以的，解决办法是，要么断言告知函数参数肯定为固定个数：</p> <div class="language- extra-class"><pre class="language-text"><code>test(...[1,'2'] as [number,string]) 
test(...[1,'2'] as const) // 这样也可以
</code></pre></div><p>要么设置函数的参数时，使用扩展参数类型, rest 参数只能是最后一个参数</p> <div class="language- extra-class"><pre class="language-text"><code>function test(...args:any[]){
}
</code></pre></div><p>再或者使用元祖定义变量：</p> <div class="language- extra-class"><pre class="language-text"><code>const params:[number,string]=[1,'2']
test(...params)
</code></pre></div><h2 id="void"><a href="#void" class="header-anchor">#</a> void</h2> <p>表示没有任何类型，不能赋值给其他类型，一般用在函数返回值上，虽然没有返回时，函数返回的是<code>undefined</code>，但是我们不能声明为<code>undefined</code>，否则报错，不返回值情况ts会自动推断出其返回类型为<code>void</code></p> <h2 id="never"><a href="#never" class="header-anchor">#</a> never</h2> <p>nerver表示永远不会存在的值的类型，有两种情况会产生：</p> <ol><li>函数抛出异常</li> <li>死循环</li></ol> <p>never同<code>undefined</code>和<code>null</code>一样都是任何类型的子类型，可以赋值给任何类型。只有<code>never</code>可以给<code>never</code>赋值</p> <p>never可以赋值给一个不可修改的空数组<code>never[]</code>，而<code>[] extends never[]</code>是成立的。参考:</p> <ol><li>pr:https://github.com/microsoft/TypeScript/pull/8944</li> <li>https://www.explainprogramming.com/typescript/never-type/</li></ol> <h2 id="unknow"><a href="#unknow" class="header-anchor">#</a> unknow</h2> <p>任何类型的值都可以赋值给<code>unknow</code>，但是只能为<code>unknow</code>和<code>any</code>赋值,<code>unknow</code>不允许定义的值有任何操作，如<code>new</code>或者方法执行等，但<code>any</code>可以</p> <h2 id="object"><a href="#object" class="header-anchor">#</a> Object</h2> <p>小写 <code>object</code>表示所有非原始数据类型。大写<code>Object</code>代表所有拥有 toString、hasOwnProperty 方法的类型，在严格模式下，null 和 undefined 类型也不能赋给 Object。</p> <p>大 Object 不仅是小 object 的父类型，同时也是小 object 的子类型</p> <p><code>{}</code>空对象类型和<code>Object</code>类型行为一致</p> <p>对象类型中的属性定义时，被视为同<code>let</code>声明变量一样，具有拓宽行为</p> <h3 id="索引类型-index-signatures"><a href="#索引类型-index-signatures" class="header-anchor">#</a> 索引类型(Index Signatures)</h3> <p>用于表示任意类型的属性,一个接口或者type中最多只能定义一个string<code>索引类型</code>和一个number索引类型</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  	age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>propName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>	
</code></pre></div><p>一旦定义了索引类型，那么确定属性和可选属性的类型都必须是它的类型的子集</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>  <span class="token comment">// 这将会提示类型“number | undefined”的属性“age”不能赋给“string”索引类型“string”</span>
  <span class="token punctuation">[</span>propName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 把这里修改成string|number|undefined就可以了，因为是可选属性，所以还要支持undefined</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> tom<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">26</span><span class="token punctuation">,</span>
  gender<span class="token operator">:</span> <span class="token string">'male'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>ts中支持两种类型的索引签名，一个是数字类型的还有一个是string类型的。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">StringArray</span> <span class="token punctuation">{</span>
  <span class="token comment">// 字符串索引 -&gt; keyof StringArray =&gt; string | number</span>
  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">StringArray1</span> <span class="token punctuation">{</span>
  <span class="token comment">// 数字索引 -&gt; keyof StringArray1 =&gt; number</span>
  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了同时支持两种索引类型，就得要求数字索引的返回值必须是字符串索引返回值的子类，这是因为当使用<code>number</code>来索引时，JavaScript 会将它转换成<code>string</code>然后再去索引对象。 也就是说用<code>100</code>（一个<code>number</code>）去索引等同于使用<code>&quot;100&quot;</code>（一个<code>string</code>）去索引，因此两者需要保持一致：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">TupleToObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token keyword">readonly</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">K</span><span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token builtin">string</span><span class="token operator">|</span><span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token constant">B</span><span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="交叉类型-intersection-types"><a href="#交叉类型-intersection-types" class="header-anchor">#</a> 交叉类型(Intersection Types)</h3> <p>通过<code>&amp;</code>定义的<code>type</code>,只能用于<code>type</code>。如果属性有重合部分，但是类型不相同，相当于是取两个类型的交集：</p> <div class="language- extra-class"><pre class="language-text"><code>type a = { a: string; b: number };
type aa = { a: string; b: string };
type aaa = a &amp; aa;
const newA:aaa = {
  a: &quot;你好&quot;,
  b: 1,
};
</code></pre></div><p>这里的<code>newA.b</code>类型为<code>never</code></p> <p>如果同名属性的类型兼容，比如一个是 number，另一个是 number 的子类型、数字字面量类型，合并后 name 属性的类型就是两者中的子类型。</p> <p>如果同名属性是非基本数据类型的话可以成功合并</p> <div class="language-ts extra-class"><pre class="language-ts"><code>nterface <span class="token constant">A</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span><span class="token punctuation">{</span>d<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span><span class="token punctuation">{</span>e<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span><span class="token punctuation">{</span>f<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">ABC</span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">&amp;</span> <span class="token constant">B</span> <span class="token operator">&amp;</span> <span class="token constant">C</span>
<span class="token keyword">let</span> abc<span class="token operator">:</span><span class="token constant">ABC</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span><span class="token punctuation">{</span>
    d<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
    e<span class="token operator">:</span><span class="token string">''</span><span class="token punctuation">,</span>
    f<span class="token operator">:</span><span class="token number">666</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>交叉类型优先级高于联合类型<code>1|2|3 &amp; 4</code>类型为<code>1|2</code></p> <h3 id="array"><a href="#array" class="header-anchor">#</a> Array</h3> <p>定义一个非空数组</p> <div class="language- extra-class"><pre class="language-text"><code>type NonEmptyArray&lt;T&gt; = [T, ...T[]]
</code></pre></div><p>展开数组,<code>[...T]</code></p> <h3 id="readonlyarray-type"><a href="#readonlyarray-type" class="header-anchor">#</a> ReadonlyArray Type</h3> <p>只读数组类型</p> <h3 id="tuple-元组"><a href="#tuple-元组" class="header-anchor">#</a> Tuple(元组)</h3> <p>类似于数组，一般用来定义长度固定的数据，<code>let x:[string,number]</code>,在长度和类型都不确定时，应使用<code>any[]</code></p> <p>通过使用剩余元素也可以用元祖标识不固定长度数据，<code>type RestTupleType= [number,...string[]]</code></p> <p>在ts 3.4中引入了只读元素的支持:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> point<span class="token operator">:</span><span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span><span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>元祖类型可以通过<code>tupleType[number]</code>转换为联合类型</p> <p>当添加越界的元素时，它的类型会被限制为元祖中，每个类型的联合类型</p> <h2 id="generics-泛型"><a href="#generics-泛型" class="header-anchor">#</a> Generics（泛型）</h2> <p>泛型的使用场景，一个函数可以接收任意类型的值，返回也是该类型的值，笨一点的方法是使用方法重载，这样可以保证返回值类型的方法可用,但是这样就需要js有多少类型，就要定义多少个函数</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">idBoolean</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">idNumber</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">idString</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre></div><p>或者使用<code>any</code>,但是这样就会导致类型判断丢失，这个时候使用泛型<code>&lt;T&gt;</code>，<code>&lt;T&gt;</code>是一个抽象类型，只有在调用时才知道类型是什么</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">identity</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span> <span class="token comment">// 使用泛型必须要先用`&lt;T&gt;`语法定义一个泛型给后边使用</span>
  <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> test2 <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span><span class="token constant">B</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span><span class="token constant">T</span><span class="token punctuation">,</span> arg2<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">B</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arg2
<span class="token punctuation">}</span>
</code></pre></div><p>其实<code>T</code>可以用任何有效名称代替，除了<code>T</code>之外还有常见的泛型变量约定:</p> <ul><li>K(Key):表示对象中的键类型；</li> <li>V(Value):表示对象中的值类型;</li> <li>E(Element):表示元素类型；</li></ul> <p>由泛型定义的函数，在执行时可以指定泛型的类型,也可以省略:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> test2 <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span><span class="token constant">B</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>arg2<span class="token operator">:</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">B</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arg2
<span class="token punctuation">}</span>
<span class="token generic-function"><span class="token function">test2</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">,</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="类型操纵"><a href="#类型操纵" class="header-anchor">#</a> 类型操纵</h3> <h4 id="映射类型"><a href="#映射类型" class="header-anchor">#</a> 映射类型</h4> <p>根据旧的类型创建出新的类型, 我们称之为映射类型</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">TestInterface</span><span class="token punctuation">{</span>
    name<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span><span class="token builtin">number</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 我们可以通过+/-来指定添加还是删除</span>
<span class="token keyword">type</span> <span class="token class-name">OptionalTestInterface<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>p <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">?</span><span class="token operator">:</span><span class="token constant">T</span><span class="token punctuation">[</span>p<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">newTestInterface</span> <span class="token operator">=</span> OptionalTestInterface<span class="token operator">&lt;</span>TestInterface<span class="token operator">&gt;</span>
</code></pre></div><h3 id="generic-constraints-泛型约束"><a href="#generic-constraints-泛型约束" class="header-anchor">#</a> Generic Constraints(泛型约束)</h3> <p>因为泛型可以表示任意类型的值，那么我们在调用该泛型的具体类型方法时，需要约束它的类型，通过使用extends对<code>T</code>进行约束，让<code>T</code>去实现这个接口</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Sizeable</span> <span class="token punctuation">{</span>
  size<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">trace</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Sizeable<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="t-number"><a href="#t-number" class="header-anchor">#</a> T[number]</h3> <p>如果T为数组类型，则可以通过该语法获取数组中的所有元素的联合类型</p> <h2 id="keyof操作符"><a href="#keyof操作符" class="header-anchor">#</a> keyof操作符</h2> <p>将一个类型映射为它所有成员名称的联合类型</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  gender<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">P</span></span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Person<span class="token punctuation">;</span> <span class="token comment">// &quot;name&quot; | &quot;age&quot; | &quot;gender&quot;</span>
</code></pre></div><p>keyof也支持基本数据类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token constant">K1</span><span class="token operator">:</span> <span class="token keyword">keyof</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span> <span class="token comment">// let K1: &quot;valueOf&quot;</span>
<span class="token keyword">let</span> <span class="token constant">K2</span><span class="token operator">:</span> <span class="token keyword">keyof</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// let K2: &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; | ...</span>
<span class="token keyword">let</span> <span class="token constant">K3</span><span class="token operator">:</span> <span class="token keyword">keyof</span> <span class="token builtin">symbol</span><span class="token punctuation">;</span> <span class="token comment">// let K1: &quot;valueOf&quot;</span>
</code></pre></div><p>使用场景是当我们需要明确的约束使用对象上存在的属性时，比如：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">prop</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> object<span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 这里约束obj为对象类型，然后key为obj的属性联合类型的子类</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">prop</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="条件类型"><a href="#条件类型" class="header-anchor">#</a> 条件类型</h2> <p>语法与js中的条件表达式一样， <code>SomeType extends OtherType ? TrueType : FalseType;</code></p> <p>与泛型一起使用时，当传入联合类型，条件类型将作用于联合类型中的每一个类型</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">ToArray<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Type <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">StrArrOrNumArr</span> <span class="token operator">=</span> ToArray<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// type StrArrOrNumArr = string[] | number[]</span>
</code></pre></div><p>这种行为是默认行为，如果想避免出现这种情况，那么需要将<code>extends</code>的两侧用<code>[]</code>括起来：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">ToArrayNonDist<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span>Type<span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">any</span><span class="token punctuation">]</span> <span class="token operator">?</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">StrArrOrNumArr</span> <span class="token operator">=</span> ToArrayNonDist<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// type StrArrOrNumArr = (string | number)[]</span>
</code></pre></div><h2 id="type-assertions-类型断言"><a href="#type-assertions-类型断言" class="header-anchor">#</a> Type Assertions（类型断言）</h2> <h3 id="as-断言"><a href="#as-断言" class="header-anchor">#</a> as 断言</h3> <p>当ts无法推断出类型的更多信息时，使用断言可以提供更多的信息，比如：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> myCanvas <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;main_canvas&quot;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> HTMLCanvasElement<span class="token punctuation">;</span>
</code></pre></div><p>还可以使用尖括号语法（不可以与<code>.tsx</code>一起使用）：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> myCanvas <span class="token operator">=</span> <span class="token operator">&lt;</span>HTMLCanvasElement<span class="token operator">&gt;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;main_canvas&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>与类型注释一样，类型断言会被编译器删除，不会影响代码的运行时行为。</p> <blockquote><p>因为类型断言在编译时被移除，所以没有与类型断言相关联的运行时检查。如果类型断言错误，则不会产生异常或空值。</p></blockquote> <p>断言只能用于父集或者子集，以下这种会报错：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token keyword">as</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="const-断言"><a href="#const-断言" class="header-anchor">#</a> const 断言</h3> <p>确保定义的变量及子属性都为只读，不可修改。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> buttonProps <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> String <span class="token keyword">as</span> PropType<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token string">'default'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  dashed<span class="token operator">:</span> Boolean<span class="token punctuation">,</span>
  iconPlacement<span class="token operator">:</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> String <span class="token keyword">as</span> PropType<span class="token operator">&lt;</span><span class="token string">'left'</span> <span class="token operator">|</span> <span class="token string">'right'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token string">'left'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  attrType<span class="token operator">:</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> String <span class="token keyword">as</span> PropType<span class="token operator">&lt;</span><span class="token string">'button'</span> <span class="token operator">|</span> <span class="token string">'submit'</span> <span class="token operator">|</span> <span class="token string">'reset'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token string">'button'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  onClick<span class="token operator">:</span> <span class="token punctuation">[</span>Function<span class="token punctuation">,</span> Array<span class="token punctuation">]</span> <span class="token keyword">as</span> PropType<span class="token operator">&lt;</span>MaybeArray<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token parameter">e<span class="token operator">:</span> MouseEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>
  bordered<span class="token operator">:</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> Boolean<span class="token punctuation">,</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">as</span> <span class="token keyword">const</span>
</code></pre></div><h3 id="非空断言"><a href="#非空断言" class="header-anchor">#</a> 非空断言</h3> <p>添加后缀表达式操作符<code>!</code>，表示断言操作对象是非<code>null</code>和<code>undefined</code>类型的</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> mayNullOrUndefinedOrString<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
mayNullOrUndefinedOrString<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
mayNullOrUndefinedOrString<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ts(2531)</span>
</code></pre></div><h3 id="确定赋值断言"><a href="#确定赋值断言" class="header-anchor">#</a> 确定赋值断言</h3> <p>允许实例属性和声明变量后边添加<code>!</code>，从而告诉ts该属性会被明确地赋值：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> num<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="双重断言"><a href="#双重断言" class="header-anchor">#</a> 双重断言</h3> <p>通常情况下，我们可以使用<code>cat as any</code>来为cat定义成任意类型，如果使用双重断言，那么就可以把一个类型断言成一个另一个不兼容的类型<code>cat as any as Fish</code>.</p> <p><strong>除非迫不得已，千万别用双重断言</strong>。</p> <h2 id="操作符"><a href="#操作符" class="header-anchor">#</a> 操作符</h2> <h3 id="in"><a href="#in" class="header-anchor">#</a> in</h3> <p>用来遍历联合类型</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Keys</span> <span class="token operator">=</span><span class="token string">&quot;a&quot;</span><span class="token operator">|</span><span class="token string">&quot;b&quot;</span><span class="token operator">|</span><span class="token string">&quot;c&quot;</span>
<span class="token keyword">type</span> <span class="token class-name">Obj</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>p <span class="token keyword">in</span> Keys<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span>
<span class="token punctuation">}</span> <span class="token comment">// -&gt; {a:any,b:any,c:any}</span>
</code></pre></div><h3 id="infer"><a href="#infer" class="header-anchor">#</a> infer</h3> <p>在条件类型语句中，可以用<code>infer</code>声明一个新的泛型并且对它进行使用</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">GetReturnType<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Type <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> infer Return
  <span class="token operator">?</span> Return
  <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
</code></pre></div><p>无法在正常类型参数的约束子语句中使用<code>infer</code>声明：</p> <div class="language- extra-class"><pre class="language-text"><code>type GetReturnType&lt;Type extends (...args: never[]) =&gt; infer Return ? Return : any&gt; 
</code></pre></div><h3 id="typeof"><a href="#typeof" class="header-anchor">#</a> typeof</h3> <p>获取变量的类型</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> n<span class="token operator">:</span> <span class="token keyword">typeof</span> s<span class="token punctuation">;</span> <span class="token comment">// string</span>
</code></pre></div><h2 id="字面量类型"><a href="#字面量类型" class="header-anchor">#</a> 字面量类型</h2> <p>字面量不仅可以表示值，还可以表示类型</p> <p>目前支持4种字面量类型：字符串字面量类型、模板字面量类型、数字字面量类型、布尔值字面量类型</p> <p>其作用是缩小类型范围，提高代码可读性</p> <div class="language-ts extra-class"><pre class="language-ts"><code>
  <span class="token keyword">let</span> specifiedStr<span class="token operator">:</span> <span class="token string">'this is string'</span> <span class="token operator">=</span> <span class="token string">'this is string'</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> specifiedNum<span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> specifiedBoolean<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">type</span> <span class="token class-name">World</span><span class="token operator">=</span> <span class="token string">'world'</span>
  <span class="token keyword">type</span> <span class="token class-name">Greeting</span> <span class="token operator">=</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>World<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token comment">// hello world</span>
</code></pre></div><h3 id="模板字符串字面量"><a href="#模板字符串字面量" class="header-anchor">#</a> 模板字符串字面量</h3> <p>如果模板中变量是联合类型，则结果类型为每个联合类型成员构成的字符串字面量的集合</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">EmailLocaleIDs</span> <span class="token operator">=</span> <span class="token string">'welcome_email'</span> <span class="token operator">|</span> <span class="token string">'email_heading'</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">FooterLocaleIDs</span> <span class="token operator">=</span> <span class="token string">'footer_title'</span> <span class="token operator">|</span> <span class="token string">'footer_sendoff'</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">AllLocaleIDs</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>EmailLocaleIDs <span class="token operator">|</span> FooterLocaleIDs<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">_id</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token comment">// &quot;welcome_email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;</span>
</code></pre></div><p>多个替换字符串的位置上的多个联合类型会进行交叉相乘</p> <h3 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h3> <p>定义单个的字面量类型并没有太大的用处，它真正的应用场景是可以把多个字面量类型组合成一个联合类型，用来描述拥有明确成员的实用的集合</p> <p>如下代码所示，我们使用字面量联合类型描述了一个明确、可 'up' 可 'down' 的集合，这样就能清楚地知道需要的数据结构了。</p> <div class="language- extra-class"><pre class="language-text"><code>type Direction = 'up' | 'down';
function move(dir: Direction) {
  // ...
}
move('up'); // ok
move('right'); // ts(2345) Argument of type '&quot;right&quot;' is not assignable to parameter of type 'Direction'
</code></pre></div><h2 id="namespace"><a href="#namespace" class="header-anchor">#</a> namespace</h2> <p>命名空间同样具有合并的特性</p> <h2 id="模块"><a href="#模块" class="header-anchor">#</a> 模块</h2> <h3 id="全局模块"><a href="#全局模块" class="header-anchor">#</a> 全局模块</h3> <p>在默认情况下，当你开始在一个新的 TypeScript 文件中写下代码时，它处于全局命名空间中。如在 foo.ts 里的以下代码。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre></div><p>如果你在相同的项目里创建了一个新的文件 bar.ts，TypeScript 类型系统将会允许你使用变量 foo，就好像它在全局可用一样：</p> <div class="language- extra-class"><pre class="language-text"><code>const bar = foo; // allowed
</code></pre></div><h3 id="文件模块"><a href="#文件模块" class="header-anchor">#</a> 文件模块</h3> <p>如果我们在ts文件中使用<code>export</code>或者<code>import</code>，那么这个文件就会被标记为一个模块，文件内定义的声明也不会“污染”全局命名空间</p> <h2 id="接口-interface"><a href="#接口-interface" class="header-anchor">#</a> 接口（interface）</h2> <p>理解：接口是用来描述对象可以做什么的，可以看做是一种协议，它约束了一类相似的”东西“都应该具有的属性,通常定义一个变量实现<code>interface</code>的时候需要严格按照<code>interface</code>中定义的属性来实现。</p> <p>一般情况下，接口首字母大写</p> <p>描述函数时的写法:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">SetPoint</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="鸭式辨型法"><a href="#鸭式辨型法" class="header-anchor">#</a> 鸭式辨型法</h3> <p>ts的类型会根据是否实现这个接口，来判断是否通过类型检测,这种方法叫做<code>duck type</code>，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>interface Config{
    a:string
}
function test(config:Config){
    console.log(config)
}
test({a:'1',b:2}) // 报错
const obj={a:'1',b:2}
test(obj) // 不报错
</code></pre></div><p>在函数参数里写对象就相当于是直接给<code>config</code>赋值，这个对象有严格的类型定义，所以不能多参或少参。但是我们在外部定义一个变量再传给函数，此时根据类型的兼容性，两种类型对象，参照<code>鸭式辨型法</code>,因为都具有<code>a</code>属性，所以可以绕过类型检查</p> <h3 id="声明数组"><a href="#声明数组" class="header-anchor">#</a> 声明数组</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">test</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>index<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token builtin">any</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="声明函数"><a href="#声明函数" class="header-anchor">#</a> 声明函数</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">f</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="类型声明"><a href="#类型声明" class="header-anchor">#</a> 类型声明</h2> <h3 id="let-vs-const"><a href="#let-vs-const" class="header-anchor">#</a> let vs const</h3> <p>const声明时，该变量为值的字面量类型，而let声明时，是该值的父类型</p> <div class="language-ts extra-class"><pre class="language-ts"><code>  <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'this is string'</span><span class="token punctuation">;</span> <span class="token comment">// str: 'this is string'</span>
  <span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// num: 1</span>
  <span class="token keyword">const</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// bool: true</span>
  <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'this is string'</span><span class="token punctuation">;</span> <span class="token comment">// str: string</span>
  <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// num: number</span>
  <span class="token keyword">let</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// bool: boolean</span>
</code></pre></div><h2 id="工具类"><a href="#工具类" class="header-anchor">#</a> 工具类</h2> <h3 id="partial-type"><a href="#partial-type" class="header-anchor">#</a> Partial Type</h3> <p>映射一个接口或者类型别名的所有第一层属性为可选：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">NewUserInfo</span> <span class="token operator">=</span> Partial<span class="token operator">&lt;</span>UserInfo<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>实现原理：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="deeppartial-type"><a href="#deeppartial-type" class="header-anchor">#</a> DeepPartial Type</h3> <p>深层映射属性可选，实现原理：</p> <div class="language- extra-class"><pre class="language-text"><code>type DeepPartial&lt;T&gt; = {
     // 如果是 object，则递归类型
    [U in keyof T]?: T[U] extends object
      ? DeepPartial&lt;T[U]&gt;
      : T[U]
};
</code></pre></div><h3 id="required-type"><a href="#required-type" class="header-anchor">#</a> Required Type</h3> <p>映射类型属性为必选</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Required<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> 
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="readonly-type"><a href="#readonly-type" class="header-anchor">#</a> Readonly Type</h3> <p><code>Readonly&lt;T&gt;</code> 的作用是将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值。</p> <p>实现原理：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="pick-type"><a href="#pick-type" class="header-anchor">#</a> Pick Type</h3> <p>Pick 从某个类型中挑出一些属性出来</p> <p>定义：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Todo</span> <span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  description<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  completed<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">TodoPreview</span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>Todo<span class="token punctuation">,</span> <span class="token string">&quot;title&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;completed&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> todo<span class="token operator">:</span> TodoPreview <span class="token operator">=</span> <span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token string">&quot;Clean room&quot;</span><span class="token punctuation">,</span>
  completed<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="record-type"><a href="#record-type" class="header-anchor">#</a> Record Type</h3> <p><code>Record&lt;K extends keyof any, T&gt;</code> 的作用是将 <code>K</code> 中所有的属性的值转化为 <code>T</code> 类型。<code>K extends keyof any</code>部分为联合类型，联合类型中的值作为属性，<code>T</code>作为这些属性的值类型。</p> <p>定义：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">PageInfo</span> <span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Page</span> <span class="token operator">=</span> <span class="token string">&quot;home&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;about&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;contact&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> x<span class="token operator">:</span> Record<span class="token operator">&lt;</span>Page<span class="token punctuation">,</span> PageInfo<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  about<span class="token operator">:</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">&quot;about&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  contact<span class="token operator">:</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">&quot;contact&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  home<span class="token operator">:</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">&quot;home&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="returntype"><a href="#returntype" class="header-anchor">#</a> ReturnType</h3> <p>用来得到一个函数的返回值类型</p> <p>定义：</p> <div class="language- extra-class"><pre class="language-text"><code>type ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (
  ...args: any[]
) =&gt; infer R
  ? R
  : any;
</code></pre></div><p>例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> foo<span class="token operator">:</span> ReturnType<span class="token operator">&lt;</span>Func<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="exclude-type"><a href="#exclude-type" class="header-anchor">#</a> Exclude Type</h3> <p>只能作用于联合类型，把第一个类型中与第二个类型有交集的类型全部排除掉，如果第一个类型为第二个类型的子集，则返回never</p> <p>定义：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Exclude<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</code></pre></div><p>例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T0</span></span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// &quot;b&quot; | &quot;c&quot;</span>
</code></pre></div><h3 id="extract-type"><a href="#extract-type" class="header-anchor">#</a> Extract Type</h3> <p>把第一个类型中与第二个类型有交集的类型提取出来，没有交集则返回never</p> <p>定义：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Extract<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">U</span></span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
</code></pre></div><p>例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T0</span></span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;f&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// &quot;a&quot;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// () =&gt;void</span>
</code></pre></div><h3 id="omit-type"><a href="#omit-type" class="header-anchor">#</a> Omit Type</h3> <p>忽略掉类型中的某些属性，第二个参数为第一个参数的联合类型</p> <p>定义：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Omit<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token builtin">any</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Exclude<span class="token operator">&lt;</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Todo</span> <span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  description<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  completed<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">TodoPreview</span> <span class="token operator">=</span> Omit<span class="token operator">&lt;</span>Todo<span class="token punctuation">,</span> <span class="token string">&quot;description&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> todo<span class="token operator">:</span> TodoPreview <span class="token operator">=</span> <span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token string">&quot;Clean room&quot;</span><span class="token punctuation">,</span>
  completed<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="nonnullable-type"><a href="#nonnullable-type" class="header-anchor">#</a> NonNullable Type</h3> <p>过滤类型中的<code>null</code>和<code>undefined</code>类型</p> <p>定义：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">NonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> extendsnull <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</code></pre></div><p>例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T0</span></span> <span class="token operator">=</span> NonNullable<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
</code></pre></div><h3 id="parameters-type"><a href="#parameters-type" class="header-anchor">#</a> Parameters Type</h3> <p>用于获取函数中的参数的元祖类型</p> <p>定义：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Parameters<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> infer <span class="token constant">P</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span>
<span class="token operator">?</span> <span class="token constant">P</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
</code></pre></div><p>例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> Parameters<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// []</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> Parameters<span class="token operator">&lt;</span>typeofArray<span class="token punctuation">.</span>isArray<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// [any]</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> Parameters<span class="token operator">&lt;</span>typeofparseInt<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// [string, (number | undefined)?]</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">D</span></span> <span class="token operator">=</span> Parameters<span class="token operator">&lt;</span>typeofMath<span class="token punctuation">.</span>max<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// number[]</span>
</code></pre></div><h2 id="dom操作"><a href="#dom操作" class="header-anchor">#</a> DOM操作</h2> <ol><li><a href="https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts" target="_blank" rel="noopener noreferrer">DOM type definitions<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="最佳实践"><a href="#最佳实践" class="header-anchor">#</a> 最佳实践</h2> <h3 id="避免出现新增联合类型没有对应的实现"><a href="#避免出现新增联合类型没有对应的实现" class="header-anchor">#</a> 避免出现新增联合类型没有对应的实现？</h3> <p>使用<code>never</code>只可以赋值给自己的特性：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Foo</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">controlFlowAnalysisWithNever</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> Foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> foo <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里 foo 被收窄为 string 类型</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> foo <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里 foo 被收窄为 number 类型</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// foo 在这里是 never</span>
    <span class="token keyword">const</span> check<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> foo<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果有一天<code>Foo</code>新增了<code>boolean</code>类型，那么会编译报错</p> <h3 id="永远不要使用-number、string、boolean、symbol、object"><a href="#永远不要使用-number、string、boolean、symbol、object" class="header-anchor">#</a> 永远不要使用`Number、String、Boolean、Symbol、Object</h3> <p>这些类型是js中的非原始封装对象类型，使用<code>number</code>, <code>string</code>, <code>boolean</code>, and <code>symbol</code></p> <h3 id="不要把逻辑相斥的属性写在一个类型中"><a href="#不要把逻辑相斥的属性写在一个类型中" class="header-anchor">#</a> 不要把逻辑相斥的属性写在一个类型中</h3> <p>比如这里的<code>isLoading</code>和<code>errorMsg</code></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
  pageContent<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  isLoading<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  errorMsg<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="使用function替代箭头函数"><a href="#使用function替代箭头函数" class="header-anchor">#</a> 使用function替代箭头函数</h3> <p>在ts中函数类型的定义需要用到<code>=&gt;</code>，使用<code>function</code>可以减少混淆</p> <h2 id="声明文件"><a href="#声明文件" class="header-anchor">#</a> 声明文件</h2> <p>为ts提供类型，一般是<code>d.ts</code>文件，使用<code>declare</code>声明外部变量或文件导入，如果是声明文件，则使用<code>module</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>declare module '*.css'
</code></pre></div><p>更多声明文件用法：https://ts.xcatliu.com/basics/declaration-files.html</p> <h3 id="declare"><a href="#declare" class="header-anchor">#</a> declare</h3> <p>声明语句，只能用来声明类型，不能定义具体实现,<code>declare namespace</code>用来表示一个对象</p> <h3 id="声明合并"><a href="#声明合并" class="header-anchor">#</a> 声明合并</h3> <p>假如 jQuery 既是一个函数，可以直接被调用 <code>jQuery('#foo')</code>，又是一个对象，拥有子属性 <code>jQuery.ajax()</code>（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">jQuery</span><span class="token punctuation">(</span>selector<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">namespace</span> jQuery <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> settings<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="声明导出commonjs包"><a href="#声明导出commonjs包" class="header-anchor">#</a> 声明导出commonjs包</h3> <p><code>export =</code></p> <h3 id="默认导出"><a href="#默认导出" class="header-anchor">#</a> 默认导出</h3> <p>只有<code>function</code>、<code>class</code> 和 <code>interface</code>可以和<code>export default</code>一起使用，其他的变量需要先定义出来，再默认导出</p> <h3 id="扩展已有模块类型"><a href="#扩展已有模块类型" class="header-anchor">#</a> 扩展已有模块类型</h3> <p>先导入，再使用<code>declare module</code>进行扩展</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// types/moment-plugin/index.d.ts</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> moment <span class="token keyword">from</span> <span class="token string">'moment'</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'moment'</span> <span class="token punctuation">{</span>
    <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> moment<span class="token punctuation">.</span>CalendarKey<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="三斜线指令"><a href="#三斜线指令" class="header-anchor">#</a> 三斜线指令</h3> <p>同<code>import</code>导入其他模块类型差不多，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 <code>import</code>：</p> <ul><li>当我们在<strong>书写</strong>一个全局变量的声明文件时</li> <li>当我们需要<strong>依赖</strong>一个全局变量的声明文件时</li></ul> <p>在全局变量的声明文件中，是不允许出现 <code>import</code>, <code>export</code> 关键字的，一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// types/jquery-plugin/index.d.ts</span>
<span class="token comment">/// &lt;reference types=&quot;jquery&quot; /&gt;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>options<span class="token operator">:</span> JQuery<span class="token punctuation">.</span>AjaxSettings<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre></div><p>三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。</p> <p>在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 <code>import</code> 导入，当然也就必须使用三斜线指令来引入了.</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// types/node-plugin/index.d.ts</span>
<span class="token comment">/// &lt;reference types=&quot;node&quot; /&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>p<span class="token operator">:</span> NodeJS<span class="token punctuation">.</span>Process<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre></div><p>reference中types表示对一个库的依赖，而path表示对一个文件的依赖</p> <h2 id="编译"><a href="#编译" class="header-anchor">#</a> 编译</h2> <ol><li><code>tsc</code>是官方提供的编译器，可以提供类型声明，类型检查，转换插件等功能</li> <li>还可以使用babel，但是有些语法不支持，好处是按需打包，不会整个引入<code>core-js</code></li></ol> <h3 id="tsc"><a href="#tsc" class="header-anchor">#</a> tsc</h3> <ol><li><code>--lib</code> ,使用这个参数可以将<code>lib</code>与<code>--target</code>解耦</li> <li><code>--traceResolution</code>可以查看路径引用，会显示导入的名字和位置，还有编译器使用的策略，从哪加载的type文件，最终是否加载成功</li> <li><code>--noResolve</code>,编译时，指定只解析哪些文件，比如<code>app.ts</code>中引入了<code>a</code>和<code>b</code>，那么使用命令<code>tsc app.ts a.ts --noResolve</code>则不会解析模块<code>b</code></li></ol> <h2 id="学习"><a href="#学习" class="header-anchor">#</a> 学习</h2> <ol><li><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener noreferrer">Typescript入门教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.patrickzhong.com/TypeScript/" target="_blank" rel="noopener noreferrer">TypeScript 使用手册<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><s>深入理解 TypeScript</s>不推荐，没有阅读顺序，且已过时，翻译很糟糕</li></ol> <h2 id="问题"><a href="#问题" class="header-anchor">#</a> 问题</h2> <h3 id="ts类型声明中遍历的几种方式"><a href="#ts类型声明中遍历的几种方式" class="header-anchor">#</a> ts类型声明中遍历的几种方式？</h3> <ol><li>对象中属性的循环，使用<code>in</code>操作符</li> <li>类型的自调用</li></ol> <h3 id="如何在已知肯定有某属性-但是该类型定义没有时-进行调用"><a href="#如何在已知肯定有某属性-但是该类型定义没有时-进行调用" class="header-anchor">#</a> 如何在已知肯定有某属性，但是该类型定义没有时，进行调用？</h3> <p>比如<code>window.foo</code>,我们可以使用<code>any</code>的特性，<code>(window as any).foo</code></p> <h3 id="定义类型的时候如何写判断语句"><a href="#定义类型的时候如何写判断语句" class="header-anchor">#</a> 定义类型的时候如何写判断语句？</h3> <ol><li>不能在定义类型时写<code>typeof</code>判断</li> <li>不能写<code>===</code></li> <li>可以写<code>extends</code>进行三元运算符判断</li></ol> <h3 id="如何绕过类型检查"><a href="#如何绕过类型检查" class="header-anchor">#</a> 如何绕过类型检查？</h3> <ol><li><p>鸭式辨型法</p></li> <li><p>类型断言<code>as</code>, 虽然不会报错，但是在使用<code>p.girl</code>的时候还是会报错</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span> 
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">let</span> p<span class="token operator">:</span> Props <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;兔神&quot;</span><span class="token punctuation">,</span>
  girl<span class="token operator">:</span> <span class="token boolean">false</span> 
<span class="token punctuation">}</span> <span class="token keyword">as</span> Props<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>索引类型</p></li> <li><p>当函数接受参数超过声明类型时，可以通过把参数写成一个变量，而不是参数语句时，可以绕过检查,这种方法只有在有共同属性的时候才可以</p></li></ol> <h3 id="如何根据对象实例创建类型"><a href="#如何根据对象实例创建类型" class="header-anchor">#</a> 如何根据对象实例创建类型？</h3> <p>一般我们都是通过定义接口或者类型别名，然后为对象赋类型，那么如何反过来操作呢，根据对象实例创建类型？</p> <p>使用<code>typeof</code>操作符即可：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> Message <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;jimmy&quot;</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    address<span class="token operator">:</span> <span class="token punctuation">{</span>
      province<span class="token operator">:</span> <span class="token string">'四川'</span><span class="token punctuation">,</span>
      city<span class="token operator">:</span> <span class="token string">'成都'</span>   
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">message</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> Message<span class="token punctuation">;</span>
</code></pre></div><h3 id="typescript-引入文件报错"><a href="#typescript-引入文件报错" class="header-anchor">#</a> TypeScript 引入文件报错</h3> <p>TypeScript引入文件时，不能引入<code>index.ts</code>文件，应该改成<code>index.js</code>或者<code>index</code></p> <h3 id="webpack打包报错"><a href="#webpack打包报错" class="header-anchor">#</a> webpack打包报错</h3> <p>原因是先进行了编译，产生了js文件，然后代码import中并没有指定文件后缀名，webpack中resolve优先引用js文件导致，改成优先引用ts文件可以解决这个问题</p> <div class="language-diff extra-class"><pre class="language-diff"><code>resolve: {
<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    extensions: [&quot;.js&quot;, &quot;.ts&quot;, &quot;.json&quot;],
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    extensions: [&quot;.ts&quot;, &quot;.js&quot;, &quot;.json&quot;],
</span></span>},
</code></pre></div><h3 id="interface和type的区别"><a href="#interface和type的区别" class="header-anchor">#</a> interface和type的区别</h3> <p>主要区别：</p> <ol><li><p>type可以定义原始数据类型、联合类型、交集类型、元祖类型，而interface不可以，一般interface用来描述对象类型</p></li> <li><p>interface和type扩展方式不同。interface通过<code>extends</code>，type通过交集类型<code>&amp;</code>进行扩展。类型别名为对象类型时，interface和type可以互相使用对方进行扩展</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>
  name<span class="token operator">:</span><span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Bear</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  honey<span class="token operator">:</span> <span class="token builtin">boolean</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Animal</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Bear</span> <span class="token operator">=</span>Animal <span class="token operator">&amp;</span> <span class="token punctuation">{</span>
  honey<span class="token operator">:</span> Boolean
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>接口可以定义多个，会自动合并，而类型别名不行</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// 同名接口自动合并</span>
<span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
  ts<span class="token operator">:</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;typescript&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 同名类型会报错</span>
<span class="token keyword">type</span> <span class="token class-name">Window</span> <span class="token operator">=</span><span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Window</span> <span class="token operator">=</span><span class="token punctuation">{</span>
  ts<span class="token operator">:</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;typescript&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <p>到底是使用type还是interface？</p> <p>ts中能用interface的尽量用interface，其他情况使用type，type更适合用在定义function的时候</p> <h3 id="类型声明和类型断言的区别"><a href="#类型声明和类型断言的区别" class="header-anchor">#</a> 类型声明和类型断言的区别？</h3> <p>类型声明：<code>const a:People = {name:&quot;zhangsan&quot;}</code>,类型断言：<code>const a = {name:&quot;zhangsan&quot;} as People</code>,类型声明更加严格，是单边兼容，需要值兼容类型，而类型断言则是两边有一个兼容即可</p> <h3 id="类型兼容"><a href="#类型兼容" class="header-anchor">#</a> 类型兼容？</h3> <ol><li><p>不同枚举类型之间是不兼容的</p></li> <li><p>对于没指定泛型参数时，所有的泛型都当做<code>any</code>进行比较</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token function-variable function">identity</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">reverse</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>y<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">U</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
identity <span class="token operator">=</span> reverse<span class="token punctuation">;</span>  <span class="token comment">// OK, because (x: any) =&gt; any matches (y: any) =&gt; any</span>
</code></pre></div></li></ol> <h3 id="为什么在exclude列表里的模块还会被编译器使用"><a href="#为什么在exclude列表里的模块还会被编译器使用" class="header-anchor">#</a> 为什么在<code>exclude</code>列表里的模块还会被编译器使用?</h3> <p>要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行<code>import</code>或使用了<code>/// &lt;reference path=&quot;...&quot; /&gt;</code>指令的文件。</p></div></article> <section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2020-05-19
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2022-06-11
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2020/05/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html" class="post-link" data-v-4e23451f>
      上一篇 : 前端工程化
    </a> <a href="/posts/2020/05/29/eslint%E6%8C%87%E5%8D%97.html" class="post-link" data-v-4e23451f>
      下一篇 : ESLint指南
    </a></section></section> <div id="post-comments" class="main-div"><!----></div></div></main> <aside class="aside" data-v-4dd605a1><div class="info-card main-div" data-v-9d847660 data-v-4dd605a1><div class="info-card-header" data-v-9d847660><img src="https://avatars.githubusercontent.com/baixiaoyu2997?s=120" alt="L.Rain" class="info-avatar" data-v-9d847660></div> <div class="info-card-body" data-v-9d847660><section class="info-nickname" data-v-9d847660>
      L.Rain
    </section> <section class="info-desc" data-v-9d847660>真实、自由、宽容</section> <section class="info-contact" data-v-9d847660><section data-v-9d847660><span title="ChengDu City, China" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>ChengDu City, China</title><use xlink:href="#icon-location" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          ChengDu City, China
        </span></span></section> <section data-v-9d847660><span title="ChengDu YeeYun Technology" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>ChengDu YeeYun Technology</title><use xlink:href="#icon-organization" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          ChengDu YeeYun Technology
        </span></span></section> <section data-v-9d847660><a href="mailto:bxy2997@sina.com" title="bxy2997@sina.com" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>bxy2997@sina.com</title><use xlink:href="#icon-email" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          bxy2997@sina.com
        </span></a></section></section></div> <div class="info-card-footer" data-v-9d847660><section class="info-sns clearfix" data-v-9d847660><a href="https://github.com/baixiaoyu2997" target="_blank" class="sns-link" data-v-9d847660><span title="GitHub: L.Rain" class="sns-icon" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1.5em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>GitHub: L.Rain</title><use xlink:href="#icon-github" data-v-9d847660 data-v-9d847660></use></svg></span></a><a href="https://weibo.com/1504398495" target="_blank" class="sns-link" data-v-9d847660><span title="新浪微博: 白晓宇V" class="sns-icon" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1.5em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>新浪微博: 白晓宇V</title><use xlink:href="#icon-weibo" data-v-9d847660 data-v-9d847660></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-4dd605a1><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>文章目录</span> <div class="post-nav-toc"><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#项目配置">项目配置</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#tsconfig-json">tsconfig.json</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#compileoptions">compileOptions</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#介绍">介绍</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#类型">类型</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#类型推断">类型推断</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#类型守卫">类型守卫</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#联合类型-union-type">联合类型(union type)</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#类型别名">类型别名</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#类型拓宽-type-widening">类型拓宽(Type Widening)</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#类型缩小-type-narrowing">类型缩小(Type Narrowing)</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#签名的种类">签名的种类</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#ts中的几种符号">ts中的几种符号</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#everyday-types">Everyday Types</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#any">any</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#枚举">枚举</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#常量枚举">常量枚举</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#class">Class</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#functions">Functions</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#函数声明方式">函数声明方式</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#overloads-重载">Overloads(重载)</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#可选参数">可选参数</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#剩余参数">剩余参数</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#扩展参数">扩展参数</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#void">void</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#never">never</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#unknow">unknow</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#object">Object</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#索引类型-index-signatures">索引类型(Index Signatures)</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#交叉类型-intersection-types">交叉类型(Intersection Types)</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#array">Array</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#readonlyarray-type">ReadonlyArray Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#tuple-元组">Tuple(元组)</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#generics-泛型">Generics（泛型）</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#类型操纵">类型操纵</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#generic-constraints-泛型约束">Generic Constraints(泛型约束)</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#t-number">T[number]</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#keyof操作符">keyof操作符</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#条件类型">条件类型</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#type-assertions-类型断言">Type Assertions（类型断言）</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#as-断言">as 断言</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#const-断言">const 断言</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#非空断言">非空断言</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#确定赋值断言">确定赋值断言</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#双重断言">双重断言</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#操作符">操作符</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#in">in</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#infer">infer</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#typeof">typeof</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#字面量类型">字面量类型</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#模板字符串字面量">模板字符串字面量</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#例子">例子</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#namespace">namespace</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#模块">模块</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#全局模块">全局模块</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#文件模块">文件模块</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#接口-interface">接口（interface）</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#鸭式辨型法">鸭式辨型法</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#声明数组">声明数组</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#声明函数">声明函数</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#类型声明">类型声明</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#let-vs-const">let vs const</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#工具类">工具类</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#partial-type">Partial Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#deeppartial-type">DeepPartial Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#required-type">Required Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#readonly-type">Readonly Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#pick-type">Pick Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#record-type">Record Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#returntype">ReturnType</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#exclude-type">Exclude Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#extract-type">Extract Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#omit-type">Omit Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#nonnullable-type">NonNullable Type</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#parameters-type">Parameters Type</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#dom操作">DOM操作</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#最佳实践">最佳实践</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#避免出现新增联合类型没有对应的实现">避免出现新增联合类型没有对应的实现？</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#永远不要使用-number、string、boolean、symbol、object">永远不要使用`Number、String、Boolean、Symbol、Object</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#不要把逻辑相斥的属性写在一个类型中">不要把逻辑相斥的属性写在一个类型中</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#使用function替代箭头函数">使用function替代箭头函数</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#声明文件">声明文件</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#declare">declare</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#声明合并">声明合并</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#声明导出commonjs包">声明导出commonjs包</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#默认导出">默认导出</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#扩展已有模块类型">扩展已有模块类型</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#三斜线指令">三斜线指令</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#编译">编译</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#tsc">tsc</a></li></ul></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#学习">学习</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#问题">问题</a><ul><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#ts类型声明中遍历的几种方式">ts类型声明中遍历的几种方式？</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#如何在已知肯定有某属性-但是该类型定义没有时-进行调用">如何在已知肯定有某属性，但是该类型定义没有时，进行调用？</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#定义类型的时候如何写判断语句">定义类型的时候如何写判断语句？</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#如何绕过类型检查">如何绕过类型检查？</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#如何根据对象实例创建类型">如何根据对象实例创建类型？</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#typescript-引入文件报错">TypeScript 引入文件报错</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#webpack打包报错">webpack打包报错</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#interface和type的区别">interface和type的区别</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#类型声明和类型断言的区别">类型声明和类型断言的区别？</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#类型兼容">类型兼容？</a></li><li><a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#为什么在exclude列表里的模块还会被编译器使用">为什么在exclude列表里的模块还会被编译器使用?</a></li></ul></li></ul></div></div> <div class="post-nav-comments"><svg class="icon"><title>comment</title><use xlink:href="#icon-comment"></use></svg> <a href="/posts/2020/05/19/typescript%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html#post-comments">
      评论
    </a></div></div></aside></div> <footer class="footer" data-v-1375e54c><p class="footer-sns-links" data-v-1375e54c><a href="https://github.com/baixiaoyu2997" target="_blank" class="sns-link" data-v-1375e54c><span title="GitHub: L.Rain" class="sns-icon" data-v-1375e54c data-v-1375e54c><svg class="icon" style="font-size:25px;" data-v-1375e54c data-v-1375e54c><title data-v-1375e54c data-v-1375e54c>GitHub: L.Rain</title><use xlink:href="#icon-github" data-v-1375e54c data-v-1375e54c></use></svg></span></a><a href="https://weibo.com/1504398495" target="_blank" class="sns-link" data-v-1375e54c><span title="新浪微博: 白晓宇V" class="sns-icon" data-v-1375e54c data-v-1375e54c><svg class="icon" style="font-size:25px;" data-v-1375e54c data-v-1375e54c><title data-v-1375e54c data-v-1375e54c>新浪微博: 白晓宇V</title><use xlink:href="#icon-weibo" data-v-1375e54c data-v-1375e54c></use></svg></span></a></p> <p class="footer-text" data-v-1375e54c><span data-v-1375e54c>Powered by </span> <a href="https://github.com/vuejs/vuepress" target="_blank" data-v-1375e54c>
      VuePress
    </a> <span data-v-1375e54c> | </span> <a href="https://github.com/meteorlxy/vuepress-theme-meteorlxy" target="_blank" data-v-1375e54c>
        meteorlxy
      </a></p> <!----></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.f3f948e5.js" defer></script><script src="/assets/js/7.8545d9f8.js" defer></script><script src="/assets/js/46.bd48e39f.js" defer></script>
  </body>
</html>
