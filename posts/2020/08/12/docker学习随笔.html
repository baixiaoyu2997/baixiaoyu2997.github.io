<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker学习随笔 | L.Rain的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <meta name="description" content="L.Rain的博客">
    <link rel="preload" href="/assets/css/0.styles.0b94e76f.css" as="style"><link rel="preload" href="/assets/js/app.f3f948e5.js" as="script"><link rel="preload" href="/assets/js/7.8545d9f8.js" as="script"><link rel="preload" href="/assets/js/19.3c94f51e.js" as="script"><link rel="prefetch" href="/assets/js/1.f6e0f07f.js"><link rel="prefetch" href="/assets/js/10.4a6afb4e.js"><link rel="prefetch" href="/assets/js/100.00690d66.js"><link rel="prefetch" href="/assets/js/101.b03e7e78.js"><link rel="prefetch" href="/assets/js/102.65326722.js"><link rel="prefetch" href="/assets/js/103.d406d78e.js"><link rel="prefetch" href="/assets/js/104.6a1f86e2.js"><link rel="prefetch" href="/assets/js/105.0f31792b.js"><link rel="prefetch" href="/assets/js/106.6c9ad918.js"><link rel="prefetch" href="/assets/js/107.ee598287.js"><link rel="prefetch" href="/assets/js/108.b5fb77fe.js"><link rel="prefetch" href="/assets/js/109.b2439d14.js"><link rel="prefetch" href="/assets/js/11.d13437d4.js"><link rel="prefetch" href="/assets/js/110.0d63ca3f.js"><link rel="prefetch" href="/assets/js/111.2c66addd.js"><link rel="prefetch" href="/assets/js/112.d6da0f6e.js"><link rel="prefetch" href="/assets/js/113.87534de5.js"><link rel="prefetch" href="/assets/js/114.9d1d8fa1.js"><link rel="prefetch" href="/assets/js/115.ff10b6f6.js"><link rel="prefetch" href="/assets/js/116.e20742ae.js"><link rel="prefetch" href="/assets/js/117.e7d8d1af.js"><link rel="prefetch" href="/assets/js/118.8ea36d1a.js"><link rel="prefetch" href="/assets/js/119.92e02005.js"><link rel="prefetch" href="/assets/js/12.7d7635cb.js"><link rel="prefetch" href="/assets/js/120.c1d798df.js"><link rel="prefetch" href="/assets/js/121.a3eb223d.js"><link rel="prefetch" href="/assets/js/13.919964bf.js"><link rel="prefetch" href="/assets/js/14.5ff823ae.js"><link rel="prefetch" href="/assets/js/15.99e9e2eb.js"><link rel="prefetch" href="/assets/js/16.cf847976.js"><link rel="prefetch" href="/assets/js/17.68c10889.js"><link rel="prefetch" href="/assets/js/18.12534d82.js"><link rel="prefetch" href="/assets/js/20.1bd9be68.js"><link rel="prefetch" href="/assets/js/21.28d796df.js"><link rel="prefetch" href="/assets/js/22.bfdfc41c.js"><link rel="prefetch" href="/assets/js/23.2a062f7f.js"><link rel="prefetch" href="/assets/js/24.e18c817e.js"><link rel="prefetch" href="/assets/js/25.722a033a.js"><link rel="prefetch" href="/assets/js/26.01e9d959.js"><link rel="prefetch" href="/assets/js/27.4b7fbb8c.js"><link rel="prefetch" href="/assets/js/28.5f5c310e.js"><link rel="prefetch" href="/assets/js/29.463b5d28.js"><link rel="prefetch" href="/assets/js/3.abcd40dc.js"><link rel="prefetch" href="/assets/js/30.d09f9f0a.js"><link rel="prefetch" href="/assets/js/31.b9416bd5.js"><link rel="prefetch" href="/assets/js/32.d180d63d.js"><link rel="prefetch" href="/assets/js/33.2b4d3a05.js"><link rel="prefetch" href="/assets/js/34.641090b9.js"><link rel="prefetch" href="/assets/js/35.d50ed1d6.js"><link rel="prefetch" href="/assets/js/36.2d2c0cbe.js"><link rel="prefetch" href="/assets/js/37.1426b4d7.js"><link rel="prefetch" href="/assets/js/38.0792bcd9.js"><link rel="prefetch" href="/assets/js/39.ee9f93e7.js"><link rel="prefetch" href="/assets/js/4.037891d1.js"><link rel="prefetch" href="/assets/js/40.4965c53c.js"><link rel="prefetch" href="/assets/js/41.dd9117e7.js"><link rel="prefetch" href="/assets/js/42.05ea98be.js"><link rel="prefetch" href="/assets/js/43.b28e38da.js"><link rel="prefetch" href="/assets/js/44.7fc33c3f.js"><link rel="prefetch" href="/assets/js/45.5eaf4dc1.js"><link rel="prefetch" href="/assets/js/46.bd48e39f.js"><link rel="prefetch" href="/assets/js/47.1406a8e4.js"><link rel="prefetch" href="/assets/js/48.680b3167.js"><link rel="prefetch" href="/assets/js/49.5d634f35.js"><link rel="prefetch" href="/assets/js/5.023c6154.js"><link rel="prefetch" href="/assets/js/50.c9d5c85b.js"><link rel="prefetch" href="/assets/js/51.3b049ffa.js"><link rel="prefetch" href="/assets/js/52.f6891e69.js"><link rel="prefetch" href="/assets/js/53.4aa54af0.js"><link rel="prefetch" href="/assets/js/54.6a9e6d10.js"><link rel="prefetch" href="/assets/js/55.8bbe2a85.js"><link rel="prefetch" href="/assets/js/56.a85b7d61.js"><link rel="prefetch" href="/assets/js/57.b595c295.js"><link rel="prefetch" href="/assets/js/58.57df37bd.js"><link rel="prefetch" href="/assets/js/59.7b090e92.js"><link rel="prefetch" href="/assets/js/6.118b5a7a.js"><link rel="prefetch" href="/assets/js/60.4d81b83e.js"><link rel="prefetch" href="/assets/js/61.2ebaff37.js"><link rel="prefetch" href="/assets/js/62.79af8aa9.js"><link rel="prefetch" href="/assets/js/63.b8fe69a6.js"><link rel="prefetch" href="/assets/js/64.f04f617d.js"><link rel="prefetch" href="/assets/js/65.a90b10c6.js"><link rel="prefetch" href="/assets/js/66.9e701cff.js"><link rel="prefetch" href="/assets/js/67.69accf88.js"><link rel="prefetch" href="/assets/js/68.02005b54.js"><link rel="prefetch" href="/assets/js/69.caca86d2.js"><link rel="prefetch" href="/assets/js/70.2aa39324.js"><link rel="prefetch" href="/assets/js/71.813d9785.js"><link rel="prefetch" href="/assets/js/72.feb39ddf.js"><link rel="prefetch" href="/assets/js/73.4166c05e.js"><link rel="prefetch" href="/assets/js/74.15141838.js"><link rel="prefetch" href="/assets/js/75.73494c15.js"><link rel="prefetch" href="/assets/js/76.85b76b27.js"><link rel="prefetch" href="/assets/js/77.d6bf62ba.js"><link rel="prefetch" href="/assets/js/78.49c87c7c.js"><link rel="prefetch" href="/assets/js/79.ec76b1f5.js"><link rel="prefetch" href="/assets/js/8.51c6e2dd.js"><link rel="prefetch" href="/assets/js/80.58b89a63.js"><link rel="prefetch" href="/assets/js/81.6ec4c951.js"><link rel="prefetch" href="/assets/js/82.9a316b1b.js"><link rel="prefetch" href="/assets/js/83.b62a35e8.js"><link rel="prefetch" href="/assets/js/84.81879853.js"><link rel="prefetch" href="/assets/js/85.96a2fd73.js"><link rel="prefetch" href="/assets/js/86.a9cf33e0.js"><link rel="prefetch" href="/assets/js/87.8eb3ec20.js"><link rel="prefetch" href="/assets/js/88.318384bb.js"><link rel="prefetch" href="/assets/js/89.3634cbfa.js"><link rel="prefetch" href="/assets/js/9.50140b23.js"><link rel="prefetch" href="/assets/js/90.0693c763.js"><link rel="prefetch" href="/assets/js/91.c8dbc323.js"><link rel="prefetch" href="/assets/js/92.9288651a.js"><link rel="prefetch" href="/assets/js/93.7488f678.js"><link rel="prefetch" href="/assets/js/94.c84bd54c.js"><link rel="prefetch" href="/assets/js/95.903d1a46.js"><link rel="prefetch" href="/assets/js/96.c483a229.js"><link rel="prefetch" href="/assets/js/97.f9d20d24.js"><link rel="prefetch" href="/assets/js/98.cb4974db.js"><link rel="prefetch" href="/assets/js/99.049f174b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0b94e76f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-meteorlxy"><header class="header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(https://picsum.photos/1920/250.webp);" data-v-7a046aea><div data-v-e4145d0a data-v-7a046aea><nav class="navbar" data-v-e4145d0a><div class="container" data-v-e4145d0a><a href="/" class="router-link-active" data-v-e4145d0a><span class="navbar-site-name" data-v-e4145d0a>
          L.Rain的博客
        </span></a> <div class="navbar-toggler" data-v-e4145d0a><svg class="icon" style="font-size:1.2em;" data-v-e4145d0a data-v-e4145d0a><title data-v-e4145d0a data-v-e4145d0a>menu</title><use xlink:href="#icon-menu" data-v-e4145d0a data-v-e4145d0a></use></svg></div> <div class="navbar-links" data-v-e4145d0a><a href="/" class="navbar-link" data-v-e4145d0a>
            主页
          </a><a href="/posts/" class="navbar-link router-link-active" data-v-e4145d0a>
            分类
          </a><a href="https://github.com/baixiaoyu2997" target="_blank" rel="noopener noreferrer" class="navbar-link" data-v-e4145d0a><span data-v-e4145d0a>Github</span> <span data-v-e4145d0a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-e4145d0a></div></div> <div class="banner" data-v-98d6aa8c data-v-7a046aea data-v-7a046aea><div class="container" data-v-98d6aa8c><div class="center" data-v-98d6aa8c><h1 data-v-98d6aa8c data-v-7a046aea>
          Docker学习随笔
        </h1></div></div></div></header> <div class="container clearfix show-aside" data-v-4dd605a1 data-v-4dd605a1><main class="main" data-v-4dd605a1><div class="post" data-v-4dd605a1 data-v-4dd605a1><section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2020-08-12
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2022-06-11
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2020/08/09/nuxt%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html" class="post-link" data-v-4e23451f>
      上一篇 : nuxt学习随笔
    </a> <a href="/posts/2020/08/21/egg%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html" class="post-link" data-v-4e23451f>
      下一篇 : egg学习随笔
    </a></section></section> <article class="main-div"><div class="post-content content content__default"><h2 id="docker-是什么"><a href="#docker-是什么" class="header-anchor">#</a> Docker 是什么？</h2> <p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。由<code>golang</code>编写。</p> <p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p> <p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p> <h2 id="为什么要用-docker"><a href="#为什么要用-docker" class="header-anchor">#</a> 为什么要用 docker？</h2> <p>用户计算机的环境都不相同，软件必须保证两件事：操作系统的设置，各种库和组件的安装，只有它们都正确，软件才能运行。<br>
环境配置如此麻烦，换一台机器，就要重来一次，旷日费时，所以产生了 docker。</p> <ol><li>环境统一</li> <li>环境隔离</li> <li>便于回滚</li> <li>创建销毁容器高效</li></ol> <h2 id="docker-中的概念"><a href="#docker-中的概念" class="header-anchor">#</a> docker 中的概念</h2> <h3 id="registry"><a href="#registry" class="header-anchor">#</a> Registry</h3> <p>镜像仓库，存储大量镜像，可以从镜像仓库拉取和推送镜像。</p> <h3 id="docker-镜像"><a href="#docker-镜像" class="header-anchor">#</a> Docker 镜像</h3> <p>类似虚拟机快照，从仓库拉取，或者在现有工具镜像上创建新镜像。通过镜像可以启动容器。<br>
关于镜像的一些概念：</p> <ul><li>虚悬镜像：强制删除一个已经运行容器的镜像，或者使用 docker pull 命令更新镜像时，镜像的名称和标签会转移到新镜像中，旧的镜像就会变成虚悬镜像，另外，在使用 docker build 构建镜像的时候，如果构建失败也会产生虚悬镜像。一般来说虚悬镜像已经没有实际用处，可以随意删除。</li></ul> <h4 id="寻找镜像流程"><a href="#寻找镜像流程" class="header-anchor">#</a> 寻找镜像流程</h4> <ol><li>现在本地寻找</li> <li>有的话使用，没有去docker hub上下载</li> <li>docker hub能否找到，如果没有返回错误</li> <li>docker hub能找到，下载这个镜像</li></ol> <h4 id="联合文件系统-unionfs"><a href="#联合文件系统-unionfs" class="header-anchor">#</a> 联合文件系统（UnionFS）</h4> <p>docker镜像上系上由一层一层的文件系统组成，这种层级的文件系统称为UnionFs</p> <h3 id="docker-容器"><a href="#docker-容器" class="header-anchor">#</a> Docker 容器</h3> <p>从镜像中创建应用环境，以单进程的方式运行。对外公开服务。是一种短暂的和一次性的环境。</p> <h3 id="docker-数据卷"><a href="#docker-数据卷" class="header-anchor">#</a> Docker 数据卷</h3> <p>数据卷可以完成数据持久化和同步操作，数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p> <ul><li>数据卷可以在容器之间共享和重用</li> <li>对数据卷的修改会立马生效</li> <li>对数据卷的更新，不会影响镜像</li> <li>卷会一直存在，直到没有容器使用</li> <li>删除容器，本地数据不会丢失</li></ul> <h3 id="docker-网络"><a href="#docker-网络" class="header-anchor">#</a> Docker 网络</h3> <p>Docker 容器之间的网络交互，可以使用端口映射的方式，其他容器可以直接通过端口实现。除该方式外还有一个容器连接（linking）系统也可以达到容器交互。（本文中 node 连接 mongodb 使用的是端口映射的方式）</p> <h3 id="host-宿主机"><a href="#host-宿主机" class="header-anchor">#</a> Host 宿主机</h3> <p>指的是当前使用的真实操作系统</p> <h3 id="linux上安装docker"><a href="#linux上安装docker" class="header-anchor">#</a> Linux上安装docker</h3> <ol><li><p>卸载旧的版本:<code>yum remove docker</code></p></li> <li><p>需要的依赖：<code>yum install -y yum-utils</code></p></li> <li><p>设置镜像的仓库</p> <div class="language-sh extra-class"><pre class="language-sh"><code>yum-config-manager <span class="token punctuation">\</span>
	--add-repo <span class="token punctuation">\</span>
	https://download.docker.com/linux/centosdpcker-ce.repo <span class="token comment"># 默认是国外的地址 </span>
	http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo <span class="token comment">#推荐使用阿里云的</span>
</code></pre></div></li> <li><p>更新yum软件包索引：<code>yum makecache fast</code></p></li> <li><p>安装docker：<code>yum install docker-ce docker-ce-cli containerd.io</code></p></li> <li><p>启动docker：<code>systemctl start docker</code></p></li> <li><p>使用<code>docker version</code>测试是否安装成功</p></li> <li><p>测试docker运行：<code>docker run hello-world</code></p></li> <li><p>查看下载的镜像：<code>docker images</code></p></li> <li><p>了解，删除docker:</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 1.卸载依赖</span>
yum remove docker-ce docker-ce-cli containerd.io
<span class="token comment"># 2.删除目录</span>
<span class="token function">rm</span> -rf /var/lib/docker
<span class="token comment"># /var/lib/docker docker的默认工作路径</span>
</code></pre></div></li> <li><p>为子用户添加权限：<code>sudo chmod 666 /var/run/docker.sock</code></p></li></ol> <h2 id="docker-操作指令"><a href="#docker-操作指令" class="header-anchor">#</a> docker 操作指令</h2> <h3 id="attach"><a href="#attach" class="header-anchor">#</a> attach</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>attach</td> <td>进入容器，查看正在执行的终端。可以用来查看正在输出的日志</td> <td>容器id</td></tr></tbody></table> <h3 id="build"><a href="#build" class="header-anchor">#</a> build</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>build</td> <td>构建镜像,<code>docker build -t myimages .</code>。<code>-t</code>表示打包出来镜像的名字，和可选的<code>tag</code>,最后的<code>.</code>表示需要打包的目录。</td> <td>-t name:tag</td></tr> <tr><td>build</td> <td><code>-f</code>表示指定dockerfile名称，默认<code>dockerfile</code></td> <td>-f name</td></tr></tbody></table> <h3 id="container"><a href="#container" class="header-anchor">#</a> container</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>container</td> <td>清空所有已停止容器</td> <td>prune</td></tr></tbody></table> <h3 id="commit"><a href="#commit" class="header-anchor">#</a> commit</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>commit</td> <td>提交容器成为一个新的镜像,可以通过该指令修改镜像</td> <td>-m=“提交的描述信息  -a=“作者” 容器id 目标镜像名:[TAG]</td></tr></tbody></table> <h3 id="cp"><a href="#cp" class="header-anchor">#</a> cp</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>cp</td> <td>拷贝容器中的文件到目的地主机路径</td> <td>容器id:容器内路径 目的地主机路径</td></tr></tbody></table> <h3 id="pull"><a href="#pull" class="header-anchor">#</a> pull</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>pull</td> <td>下载拉取镜像,此指令不需要登录</td> <td></td></tr></tbody></table> <p>如果权限被拒绝，需要为docker.sock赋权限：</p> <div class="language- extra-class"><pre class="language-text"><code>sudo chmod 666 /var/run/docker.sock
</code></pre></div><h3 id="push"><a href="#push" class="header-anchor">#</a> push</h3> <p>推送镜像到远程仓库，需要本地镜像名等于<code>仓库名/镜像名</code>，不需要远程创建仓库也可推送</p> <h3 id="history"><a href="#history" class="header-anchor">#</a> history</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>history</td> <td>查看镜像构建过程</td> <td>&lt;镜像id&gt;</td></tr></tbody></table> <h3 id="info"><a href="#info" class="header-anchor">#</a> info</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>info</td> <td>docker信息</td> <td></td></tr></tbody></table> <h3 id="inspect"><a href="#inspect" class="header-anchor">#</a> inspect</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>inspect</td> <td>查看容器的元信息（目前没有办法查看docker指令的记录）</td> <td>容器id</td></tr></tbody></table> <h3 id="images"><a href="#images" class="header-anchor">#</a> images</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>images</td> <td>查看当前所有本地镜像</td> <td></td></tr> <tr><td>images</td> <td>查看当前所有本地镜像+中间层镜像</td> <td>-a</td></tr> <tr><td>images</td> <td>只显示镜像的id</td> <td>-q</td></tr> <tr><td>rmi</td> <td>删除镜像</td> <td><code>&lt;image name&gt;</code></td></tr> <tr><td>rmi</td> <td>强制删除镜像</td> <td>-f <code>&lt;image name&gt;</code></td></tr> <tr><td>rmi</td> <td>删除所有镜像</td> <td>-f $(docker images -aq)</td></tr> <tr><td>image</td> <td>删除虚悬镜像</td> <td>prune</td></tr> <tr><td>image</td> <td>创建镜像，并定义镜像名</td> <td>build -t &lt;镜像名&gt; &lt;路径&gt;</td></tr></tbody></table> <h3 id="load"><a href="#load" class="header-anchor">#</a> load</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>load</td> <td>导入镜像</td> <td>-i &lt;镜像.tar&gt;</td></tr></tbody></table> <h3 id="logs"><a href="#logs" class="header-anchor">#</a> logs</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>logs</td> <td>显示日志,t表示时间戳，f表示输出，tail表示条数</td> <td>-tf --tail 10 &lt;镜像id&gt;</td></tr></tbody></table> <h3 id="tag"><a href="#tag" class="header-anchor">#</a> tag</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>tag</td> <td>修改镜像名称和标签,此操作会保留原镜像</td> <td>&lt;原镜像名：原标签&gt; &lt;镜像名：标签&gt;</td></tr></tbody></table> <h3 id="top"><a href="#top" class="header-anchor">#</a> top</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>top</td> <td>查看容器中进程信息</td> <td>容器id</td></tr></tbody></table> <h3 id="run"><a href="#run" class="header-anchor">#</a> run</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>run</td> <td>新建并启动容器，设置容器名称,有多个参数存在时，一般镜像名保持在最后，除非后边跟命令。</td> <td>--name &lt;容器名&gt; &lt;镜像名&gt;</td></tr> <tr><td>run</td> <td>新建并启动容器，<code>-t</code>配置一个伪终端，并绑定到容器的输入上，<code>-i</code>能让容器的标准输入保持打开状态，<code>-d</code>则可以让容器在后台保持运行，这三个参数可以合并为<code>-dit</code>，其顺序没有影响</td> <td>-dit &lt;镜像名&gt;</td></tr> <tr><td>run</td> <td>容器停止后自动删除</td> <td>--rm</td></tr> <tr><td>run</td> <td>指定容器的端口，例如<code>-p 3344:8080</code>,前边的3344是主机的端口，8080是容器内部的端口</td> <td>-p</td></tr> <tr><td>run</td> <td>随机指定端口</td> <td>-P</td></tr> <tr><td>run</td> <td>指定环境变量，例如：<code>docker run -e MYQSL_ROOT=my-secret-pw</code></td> <td>-e</td></tr></tbody></table> <h3 id="ps"><a href="#ps" class="header-anchor">#</a> ps</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>ps</td> <td>查看当前运行的容器</td> <td></td></tr> <tr><td>ps</td> <td>查看所有容器</td> <td>-a</td></tr> <tr><td>ps</td> <td>显示最近创建的容器，<code>n</code>表示几个</td> <td>-n=?</td></tr></tbody></table> <h3 id="exec"><a href="#exec" class="header-anchor">#</a> exec</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>exec</td> <td>进入容器并打开一个新的终端,如果只是想执行容器中的命令，可以不输入<code>bash</code>，替换成命令名，退出容器，输入<code>exit</code>,与attach区别是退出终端不会结束容器</td> <td>-it &lt;容器名字｜容器 id&gt; bash</td></tr></tbody></table> <h3 id="search"><a href="#search" class="header-anchor">#</a> search</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>search</td> <td>查找镜像</td> <td>&lt;容器名&gt;</td></tr></tbody></table> <h3 id="save"><a href="#save" class="header-anchor">#</a> save</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>save</td> <td>导出镜像</td> <td>-o &lt;输出文件名.tar&gt; &lt;待导出镜像名&gt;</td></tr></tbody></table> <h3 id="start"><a href="#start" class="header-anchor">#</a> start</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>start</td> <td>启动容器,重启使用<code>restart</code></td> <td>&lt;容器名&gt;</td></tr></tbody></table> <h3 id="stop"><a href="#stop" class="header-anchor">#</a> stop</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>stop</td> <td>停止容器</td> <td>&lt;容器名&gt;</td></tr></tbody></table> <h3 id="volume"><a href="#volume" class="header-anchor">#</a> volume</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>volume</td> <td>查看数据卷</td> <td>ls</td></tr> <tr><td>volume</td> <td>创建数据卷</td> <td>create</td></tr> <tr><td>volume</td> <td>删除所有未使用的本地数据卷</td> <td>prune</td></tr> <tr><td>volume</td> <td>删除一个或者所有数据卷</td> <td>rm</td></tr></tbody></table> <h3 id="kill"><a href="#kill" class="header-anchor">#</a> kill</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>kill</td> <td>暴力停止容器</td> <td>&lt;容器名&gt;</td></tr></tbody></table> <h3 id="rm"><a href="#rm" class="header-anchor">#</a> rm</h3> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>rm</td> <td>删除容器</td> <td>&lt;容器名&gt;</td></tr> <tr><td>rm</td> <td>强制删除容器</td> <td>-f &lt;容器名&gt;</td></tr> <tr><td>rm</td> <td>强制删除所有容器</td> <td>-f $(docker ps -aq)</td></tr></tbody></table> <h3 id="rename"><a href="#rename" class="header-anchor">#</a> rename</h3> <p>修改容器名称</p> <h2 id="docker-数据卷-2"><a href="#docker-数据卷-2" class="header-anchor">#</a> Docker 数据卷</h2> <p>数据卷可以完成数据持久化和同步操作，语法：<code>docker run -it -v &lt;主机目录&gt;:&lt;容器目录&gt; centos /bin/bash</code></p> <p>运行之后通过<code>docker inspect &lt;容器id&gt;</code>指令查看返回结果中的<code>Mounts</code>，来检测是否挂载成功：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token property">&quot;Mounts&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{</span>
                <span class="token property">&quot;Type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;bind&quot;</span><span class="token punctuation">,</span>
                <span class="token property">&quot;Source&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/Users/l.rain/Documents/workspace/DEMO/html/copy&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 主机路径</span>
                <span class="token property">&quot;Destination&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/copy&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 容器路径</span>
                <span class="token property">&quot;Mode&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
                <span class="token property">&quot;RW&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
                <span class="token property">&quot;Propagation&quot;</span><span class="token operator">:</span> <span class="token string">&quot;rprivate&quot;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
</code></pre></div><h3 id="匿名挂载"><a href="#匿名挂载" class="header-anchor">#</a> 匿名挂载</h3> <p>如果在使用<code>-v</code>时未指定主机目录，只有容器目录:<code>docker run -it /etc/test centos /bin/bash</code>，则在<code>docker volume ls</code>查看时，name为随机字符串。</p> <h3 id="具名挂载"><a href="#具名挂载" class="header-anchor">#</a> 具名挂载</h3> <p>如果在使用<code>-v</code>时主机目录不是<code>/</code>开头，则认为这是数据卷的名称:<code>docker run -it juming:/etc/test centos /bin/bash</code>，在<code>docker volume ls</code>查看时，name为该名称。</p> <h3 id="查看挂载目录位置"><a href="#查看挂载目录位置" class="header-anchor">#</a> 查看挂载目录位置</h3> <p>使用指令<code>docker volume inspect jumin</code>，返回结果中查找<code>Mountpoint</code>属性为该数据卷挂载位置。所有的docker容器内的卷，没有指定目录的情况下都是在<code>/var/lib/docker/volumes/xxx/_data</code>文件夹中。</p> <h3 id="读写权限"><a href="#读写权限" class="header-anchor">#</a> 读写权限</h3> <p>容器位置尾部添加<code>:ro</code>或者<code>:rw</code>（默认值）添加只读或读写权限，例如：<code>docker run -it juming:/etc/test:ro centos /bin/bash</code>。</p> <p>设置为<code>ro</code>后就说明这个路径只能通过宿主机来操作，容器内部是无法操作的。</p> <h3 id="数据卷容器"><a href="#数据卷容器" class="header-anchor">#</a> 数据卷容器</h3> <p>把一个容器内的数据同步到其他容器中，使用指令<code>volumes-form</code>,语法：<code>volumes-form &lt;容器名称&gt;</code>例如:<code>docker run -it --name docker02 --volumes-from docker01 kuangshen/centos:1.0</code></p> <p>删除数据卷容器不会使其他容器中的数据丢失，原理是，各个容器间的数据卷是同步拷贝的关系，如果删除数据卷容器，只是停止拷贝。</p> <h2 id="dockerfile"><a href="#dockerfile" class="header-anchor">#</a> Dockerfile</h2> <div class="language- extra-class"><pre class="language-text"><code># Dockerfile文件
FROM ubuntu:16.04
ENV WORK_DIR=/workspace
WORKDIR ${WORK_DIR}
COPY . ${WORK_DIR}
RUN npm start
</code></pre></div><p>Dockerfile 是一个文本文件，包含了镜像构建的所有命令，通过修改 Dockerfile 中的命令，就能定制化自己想要的镜像。Dockerfile 里面每一个指令都会构建一层镜像，层层叠加最终得到定制化镜像。</p> <h3 id="add"><a href="#add" class="header-anchor">#</a> ADD</h3> <p><code>ADD</code> ADD 指令和 COPY 类似，但包含更多功能，比如可以从一个网址下载文件到目标目录中（下载后文件默认权限是 600），另外一个常用的功能是自动解压，支持 gzip、bzip2 和 xz 压缩格式，比如 ADD file.tar /会将压缩包解压到目标路径中。由于 ADD 指令语义不够清晰，除了需要自动解压的情况，我们一般都不推荐使用 ADD 指令。</p> <h3 id="copy"><a href="#copy" class="header-anchor">#</a> COPY</h3> <p><code>COPY</code>指令可以将宿主机中的文件在构建镜像时复制到镜像存储中。COPY命令在拷贝文件夹时，目的地址应该加上该文件夹名，例如：<code>COPY logs /root/logs</code>
COPY命令可以一次拷贝多个文件：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>COPY README.md package.json gulpfile.js __BUILD_NUMBER ./
// 或者
COPY <span class="token punctuation">[</span><span class="token string">&quot;__BUILD_NUMBER&quot;</span>, <span class="token string">&quot;README.md&quot;</span>, <span class="token string">&quot;gulpfile&quot;</span>, <span class="token string">&quot;another_file&quot;</span>, <span class="token string">&quot;./&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>但是这种写法对文件夹无效，如果你写<code>COPY dir1 dir2 ./</code>,实际上等于：<code>COPY dir1/* dir2/* ./</code></p> <p><code>.dockerignore</code> 指定的文件不会拷贝</p> <h3 id="cmd"><a href="#cmd" class="header-anchor">#</a> CMD</h3> <p>CMD 指令可以用来指定容器启动后默认的运行命令。<code>CMD</code> 运行格式：CMD [&quot;可执行文件&quot;, &quot;参数 1&quot;, &quot;参数 2&quot;...]。</p> <p>但能被<code>docker run</code>命令后面的命令行参数替换。比如：</p> <div class="language- extra-class"><pre class="language-text"><code># Dockerfile
CMD echo &quot;Hello world&quot;
# bash
docker run -it [image]将输出Hello world
# bash
docker run -it [image] /bin/bash 将会忽略掉CMD，什么也不输出。
</code></pre></div><h3 id="env"><a href="#env" class="header-anchor">#</a> ENV</h3> <p><code>ENV</code>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。它有俩种写法：</p> <div class="language- extra-class"><pre class="language-text"><code>ENV &lt;key&gt; &lt;value&gt;
ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;
</code></pre></div><h3 id="entrypoint"><a href="#entrypoint" class="header-anchor">#</a> ENTRYPOINT</h3> <p>与<code>CMD</code>的区别就是，当启动容器时，如果添加命令会覆盖掉CMD中的内容，而指定<code>ENTRYPOINT</code>后，添加的命令会出现在<code>ENTRYPOINT</code>的命令后，相当于追加到后边。</p> <h3 id="expose"><a href="#expose" class="header-anchor">#</a> EXPOSE</h3> <p><code>EXPOSE</code> 声明将容器内的某个端口导出供外部访问，并没有实际功能，导出端口还是需要在命令行中添加<code>-p</code></p> <h3 id="from"><a href="#from" class="header-anchor">#</a> FROM</h3> <p><code>FROM</code>指令代表基于哪个镜像进行修改，第一条指令必须是 FROM 指令，若我们不想基于任何镜像，可以写 FROM scratch 即可完全从零开始构建镜像。</p> <h3 id="maintainer"><a href="#maintainer" class="header-anchor">#</a> MAINTAINER</h3> <p>镜像是谁写的，姓名+邮箱</p> <h3 id="volume-2"><a href="#volume-2" class="header-anchor">#</a> VOLUME</h3> <p>挂载的目录</p> <h3 id="workdir"><a href="#workdir" class="header-anchor">#</a> WORKDIR</h3> <p><code>WORKDIR</code>为<code>RUN、CMD、ENTRYPOINT</code> 指令配置工作目录。如果不存在则会创建该名录。如果之前有设置<code>WORKDIR</code>，则可以使用它的相对路径。在刚进入容器时，系统会自动转到工作目录，默认的工作目录是根目录/。</p> <p>可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如:</p> <div class="language- extra-class"><pre class="language-text"><code>WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
# 则最终路径为 /a/b/c 。
</code></pre></div><h3 id="onbuild"><a href="#onbuild" class="header-anchor">#</a> ONBUILD</h3> <p>当构建一个被继承DockerFile这个时候就会运行ONBUILD的指令，触发指令。</p> <h3 id="run-2"><a href="#run-2" class="header-anchor">#</a> RUN</h3> <p>使用 RUN 指令安装应用和软件包，构建镜像。<code>dockerfile</code>可以有多个<code>RUN</code>指令。由于一条指令就会创建一层镜像，而镜像层数是有限制的，一般是 127 层，当我们需要执行多条命令时，一般都用&amp;&amp;连接多条命令，从而节省镜像层数。执行时机是在容器启动之前。</p> <h2 id="docker-compose"><a href="#docker-compose" class="header-anchor">#</a> docker-compose</h2> <h3 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h3> <p>是将你的多个 docker 容器服务整合起来的命令行工具，假设你有一个 MySQL 实例和一个 Node.js 实例分别部署在两个容器中，仅需一个<code>docker-compose.yml</code>文件，docker-compose 就可以为你完成从打包到运行的所有步骤。</p> <p>docker-compose下启动的服务都在同一个网络下（域名访问）</p> <h3 id="安装"><a href="#安装" class="header-anchor">#</a> 安装</h3> <p>本地开发环境中docker内置了docker-compose，但是服务器环境需要安装依赖：</p> <ul><li>在 terminal 中运行 <code>sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-$(uname -s)-(uname -m) -o /usr/local/bin/docker-compose</code> 下载 docker-compose 的安装脚本</li> <li>官方地址很慢，使用国内地址：<code>sudo curl -L &quot;https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code></li> <li>为脚本添加执行权限<code>sudo chmod +x /usr/local/bin/docker-compose</code></li> <li>执行脚本<code>sh /usr/local/bin/docker-compose</code></li></ul> <h3 id="容器编排"><a href="#容器编排" class="header-anchor">#</a> 容器编排</h3> <p>docker-compose 使用目录下的<code>docker-compose.yml</code> 作为项目的配置文件， 以上述我们举的 MySQL 和 Node.js 应用的例子 <code>docker-compose.yml</code> 文件应该具有类似以下的结构：</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span>latest
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'3306:3306'</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> <span class="token string">'123456'</span>
  <span class="token key atrule">webapp</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> webapp
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'mysql'</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">NODE_ENV</span><span class="token punctuation">:</span> <span class="token string">'production'</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'80:8080'</span>
</code></pre></div><h3 id="流程"><a href="#流程" class="header-anchor">#</a> 流程</h3> <ol><li>创建网络</li> <li>执行<code>Docker-compose yaml</code></li> <li>依据当前项目所在文件夹名+services中的服务名称+<code>n</code>,创建镜像名。</li> <li>启动服务</li> <li>如果提示镜像不存在，则再次运行<code>docker-compose build</code></li></ol> <h3 id="指令"><a href="#指令" class="header-anchor">#</a> 指令</h3> <h4 id="up"><a href="#up" class="header-anchor">#</a> up</h4> <p>启动服务，输入参数<code>-d</code>可以后台运行。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker compose up -d
</code></pre></div><p>命名规则：用<code>docker compose</code>创建的容器，名字都会加入一个对应文件夹的名字，比如我在的文件夹叫做<code>test</code>,而我在<code>yaml</code>文件中起的名字是<code>my-wordpress</code>。最终容器的名字就是<code>test_my-wordpress_1</code></p> <p>这个前缀其实是可以改的，比如我们希望前缀加上<code>jspang</code>。就可以使用<code>-p</code>参数。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker-compose -p jspang up -d
</code></pre></div><p>你也可以在<code>yaml</code>文件里指定这个名字,方法是使用<code>contaner_name: xxx</code>但是这样作就会完全省略前缀和后缀。</p> <div class="language-SH extra-class"><pre class="language-sh"><code>version: <span class="token string">&quot;3.8&quot;</span>
services:
  my-wordpress:
        container_name: jspang
    image: wordpress:latest
    ports:
      - <span class="token number">80</span>:80
</code></pre></div><p>额外参数：</p> <ol><li><code>--build</code>:重新构建</li></ol> <h4 id="ps-2"><a href="#ps-2" class="header-anchor">#</a> ps</h4> <p>查看<code>service</code>运行情况，使用<code>docker-compose ps</code>命令</p> <h4 id="down"><a href="#down" class="header-anchor">#</a> down</h4> <p>停止，也可以<code>ctrl+c</code></p> <h4 id="stop-2"><a href="#stop-2" class="header-anchor">#</a> stop</h4> <p>停止service：<code>docker compose stop</code></p> <h4 id="rm-2"><a href="#rm-2" class="header-anchor">#</a> rm</h4> <p>删除容器，<code>docker compose rm</code></p> <p>命令会删除掉由<code>docker compose</code>所建立的容器，但用docker命令创建的容器不会被删除，对应的网络也不会被删除</p> <h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="header-anchor">#</a> docker-compose.yml</h3> <p>使用yml文件时需要指定兼容的docker版本，具体对应版本在这里<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener noreferrer">查看<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>yml文件总共有3层：</p> <ol><li>version:</li> <li>services:
<ol><li>服务:
<ol><li>docker配置</li></ol></li></ol></li> <li>其他配置 网络/卷挂载、全局规则，<code>volumes、networks、configs</code>等</li></ol> <h4 id="serverces"><a href="#serverces" class="header-anchor">#</a> serverces</h4> <ol><li>depends_on:依赖项，会决定容器的启动顺序</li> <li>stdin_open: true|false，与<code>-i</code>相同</li> <li>command:覆盖docker指令中的<code>CMD</code></li></ol> <h2 id="docker发布镜像"><a href="#docker发布镜像" class="header-anchor">#</a> docker发布镜像</h2> <ol><li>注册dockerhub账号</li> <li>命令行登录dockerhub：<code>docker login -u &lt;用户名&gt;</code></li> <li>发布：<code>docker push &lt;用户名&gt;/&lt;镜像名&gt;:&lt;版本号&gt;</code>，如果需要版本号，需要先在本地使用<code>docker tag</code>打上标签，才能发布。</li></ol> <h4 id="阿里云发布镜像"><a href="#阿里云发布镜像" class="header-anchor">#</a> 阿里云发布镜像</h4> <ol><li>登录阿里云后找到容器镜像服务</li> <li>创建命名空间</li> <li>然后去镜像仓库创建</li> <li>然后按照仓库中的操作指南一步一步走就可以了。</li></ol> <h2 id="调试"><a href="#调试" class="header-anchor">#</a> 调试</h2> <ol><li>查看容器输出：<code>docker logs -f contianer_name/container_id</code></li> <li>打印出容器的端口映射、目录挂载、网络等等：<code>docker inspect contianer_name/container_id</code></li> <li>build命令前加<code>DOCKER_BUILDKIT=0</code>可以查看更多信息</li></ol> <h2 id="docker-部署流程"><a href="#docker-部署流程" class="header-anchor">#</a> docker 部署流程</h2> <ol><li>首先在项目根目录下创建<code>.dockerignore</code>文件，防止打包不必要的文件：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>.git
node_modules
</code></pre></div><ol start="2"><li>项目根目录中创建<code>Dockerfile</code>文件：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>FROM node:10.0
# 在容器中创建一个目录
RUN mkdir -p /usr/src/nodejs/
# 定位到容器的工作目录
WORKDIR /usr/src/nodejs/
# RUN/COPY/ADD 是分层的，package.json 提前，只要没修改，就不会重新安装包
COPY package.json /usr/src/app/package.json
RUN cd /usr/src/app/
RUN npm i
# 把当前目录下的所有文件拷贝到 Image 的 /usr/src/nodejs/ 目录下
COPY . /usr/src/nodejs/
EXPOSE 3000
CMD npm start
</code></pre></div><ol start="3"><li>构建镜像</li></ol> <div class="language- extra-class"><pre class="language-text"><code>docker build -t ubuntu_demo:latest .
</code></pre></div><ol start="4"><li><p>publish镜像</p> <div class="language- extra-class"><pre class="language-text"><code>docker login
docker tag [本地镜像] [doker hub远程仓库名称]
docker push [doker hub远程仓库名称]
</code></pre></div></li></ol> <h2 id="docker网络"><a href="#docker网络" class="header-anchor">#</a> docker网络</h2> <h3 id="docker0"><a href="#docker0" class="header-anchor">#</a> docker0</h3> <p>mac环境下没有docker0，linux环境有，默认安装docker后都会产生一个docker0网卡。所有容器不指定网络的情况下，都是走docker0路由的，docker会给容器分配一个默认的可用ip</p> <ol><li>每启动一个docker容器，docker就会给docker容器分配一个ip，因为使用了linux的<code>veth-pair</code>技术，就是一堆的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连。正因为这个特性，veth-pair充当一个桥梁，链接各种虚拟网络设备的。</li> <li>因为上面的特性，docker容器之间可以相互ping通</li></ol> <p>![image-20210907164131824](/Users/l.rain/Library/Application Support/typora-user-images/image-20210907164131824.png)</p> <p>Docker使用的是Linux的桥接，宿主机中是一个Docker容器的网桥docker0，docker中的所有的网络接口都是虚拟的。虚拟的转发效率高。</p> <p>只要容器删除，对应网桥一对就没了。</p> <p>docker每次重启都会变更ip。</p> <h3 id="link-不建议使用"><a href="#link-不建议使用" class="header-anchor">#</a> --link （不建议使用）</h3> <p>容器之间是不可以通过服务名ping通的，如果想做到这一点，那么启动容器时使用<code>--link &lt;容器名&gt;</code>指定需要ping通的容器名，但是只能单向访问，不是双向的。</p> <p>实质：是在相应容器中的hosts配置中添加了一个ip映射。</p> <p>不建议使用：docker0无法自定义网络，不支持容器名链接访问。</p> <h3 id="自定义网络"><a href="#自定义网络" class="header-anchor">#</a> 自定义网络</h3> <h4 id="网络模式"><a href="#网络模式" class="header-anchor">#</a> 网络模式</h4> <ol><li>bridge：桥接docker（默认，推荐）</li> <li>none：不配置网络</li> <li>host：和宿主机共享网络</li> <li>container：容器网络联通（用得少，局限很大）</li></ol> <h4 id="测试"><a href="#测试" class="header-anchor">#</a> 测试</h4> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run -d -P --name tomcat01 tomcat <span class="token comment">#当我们执行这条语句时，相当于执行下边的默认值语句</span>
docker run -d -P --name tomcat01 --net bridge tomcat 
</code></pre></div><p>因为docker0的特点：域名不能访问。我们可以自定义一个网络</p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker network create --driver bridge --subnet <span class="token number">192.168</span>.0.0/16 --gateway <span class="token number">192.168</span>.0.1 mynet
</code></pre></div><p>自定义的网络可以用来在docker创建镜像时指定，例如：<code>--net mynet</code>。</p> <p>自定义网络的好处：</p> <ol><li>不需要<code>--link</code>,就可以ping通其他容器。</li> <li>可以直接通过容器名ping通</li></ol> <h4 id="网络连通"><a href="#网络连通" class="header-anchor">#</a> 网络连通</h4> <p>如何把容器链接到一个网络上？把当前容器的网络放到另一个容器下，也就是一个容器两个ip地址。</p> <p>使用<code>docker network connect &lt;容器1&gt; &lt;容器2&gt;</code>,依旧是单向连接的。</p> <h2 id="linux"><a href="#linux" class="header-anchor">#</a> Linux</h2> <h3 id="启动docker"><a href="#启动docker" class="header-anchor">#</a> 启动docker</h3> <p>启动docker：<code>sudo systemctl start docker</code></p> <h2 id="最佳实践"><a href="#最佳实践" class="header-anchor">#</a> 最佳实践</h2> <ol><li>选择更小的镜像，相较于其他发行版镜像，<code>Alpine</code>版更小，仅包含最小的必须的软件包</li> <li>减少 Docker 的层数。<br>
COPY、ADD 和 RUN 会向镜像中添加新层，Docker 的层就像是 git 的提交一样，Docker 的层用于保存镜像的上一版本和当前版本之间的差异。当你向注册表请求镜像时，只是下载你尚未拥有的层。<br>
层会占用空间，拥有的层越多，最终的镜像就越大</li> <li>镜像加速：如果使用阿里云镜像，那么可以在<code>镜像中心-&gt;镜像加速器</code>中查看如何配置加速器。</li> <li>docker项目目录应使用一个全新的目录，防止其他问题出现</li> <li>前端优化：https://zhuanlan.zhihu.com/p/102853707</li></ol> <h2 id="问题"><a href="#问题" class="header-anchor">#</a> 问题</h2> <h3 id="docker-build与yarn一起使用"><a href="#docker-build与yarn一起使用" class="header-anchor">#</a> docker build与yarn一起使用</h3> <p>报错<code>Couldn't find the binary git</code>,原因是yarn必须依赖git,在安装包前使用<code>RUN apk add --no-cache git</code>安装git</p> <h3 id="docker为什么-d后台启动容器后-容器停止了"><a href="#docker为什么-d后台启动容器后-容器停止了" class="header-anchor">#</a> docker为什么<code>-d</code>后台启动容器后，容器停止了？</h3> <p>docker容器使用后台运行，就必须要有一个前台进程，，否则docker发现没有应用，就会自动停止。</p> <h3 id="docker镜像挂载外部文件"><a href="#docker镜像挂载外部文件" class="header-anchor">#</a> docker镜像挂载外部文件？</h3> <p>比如说想加载一个外部配置文件或者一个目录，那么可以通过以下方式指定：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker run -it -v /test:/soft centos /bin/bash  
</code></pre></div><p>冒号&quot;:&quot;前面的目录是宿主机目录，后面的目录是容器内目录。</p> <blockquote><p>参考 https://www.cnblogs.com/shix0909/p/11124466.html</p></blockquote> <h3 id="删除所有none标签镜像"><a href="#删除所有none标签镜像" class="header-anchor">#</a> 删除所有none标签镜像</h3> <div class="language- extra-class"><pre class="language-text"><code>docker images | grep none | awk '{ print $3; }' | xargs docker rmi
</code></pre></div><h3 id="删除所有-images"><a href="#删除所有-images" class="header-anchor">#</a> 删除所有 images</h3> <blockquote><p>删除镜像需要先删除一次镜像为基础的容器</p></blockquote> <p><code>docker rmi --force $(docker images -q)</code></p> <h3 id="删除所有镜像和容器"><a href="#删除所有镜像和容器" class="header-anchor">#</a> 删除所有镜像和容器</h3> <div class="language-text extra-class"><pre class="language-text"><code>docker system prune -a
</code></pre></div><h3 id="删除名称中包含某个字符串的镜像"><a href="#删除名称中包含某个字符串的镜像" class="header-anchor">#</a> 删除名称中包含某个字符串的镜像</h3> <div class="language- extra-class"><pre class="language-text"><code># 例如删除包含“some”的镜像
docker rmi --force $(docker images | grep some | awk '{print $3}')
</code></pre></div><h3 id="mac无法ping通容器中的ip"><a href="#mac无法ping通容器中的ip" class="header-anchor">#</a> mac无法ping通容器中的ip？</h3> <p>因为mac在容器和主机中间有一层<code>docker vm</code>,所以ping不通，进到<code>docker vm</code>里就可以ping通了。</p> <h3 id="配置-p后公网ip无法访问"><a href="#配置-p后公网ip无法访问" class="header-anchor">#</a> 配置-p后公网ip无法访问？</h3> <p>原因有可能是服务器没有添加相关端口的防火墙规则</p> <h2 id="学习资源"><a href="#学习资源" class="header-anchor">#</a> 学习资源</h2> <ol><li><a href="https://www.bilibili.com/video/BV1og4y1q7M4" target="_blank" rel="noopener noreferrer">【狂神说Java】Docker最新超详细版教程通俗易懂<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h2> <p><a href="https://www.cnblogs.com/ryanyangcs/p/12558727.html" target="_blank" rel="noopener noreferrer">两个奇技淫巧，将 Docker 镜像体积减小 99%<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></article> <section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2020-08-12
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2022-06-11
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2020/08/09/nuxt%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html" class="post-link" data-v-4e23451f>
      上一篇 : nuxt学习随笔
    </a> <a href="/posts/2020/08/21/egg%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html" class="post-link" data-v-4e23451f>
      下一篇 : egg学习随笔
    </a></section></section> <div id="post-comments" class="main-div"><!----></div></div></main> <aside class="aside" data-v-4dd605a1><div class="info-card main-div" data-v-9d847660 data-v-4dd605a1><div class="info-card-header" data-v-9d847660><img src="https://avatars.githubusercontent.com/baixiaoyu2997?s=120" alt="L.Rain" class="info-avatar" data-v-9d847660></div> <div class="info-card-body" data-v-9d847660><section class="info-nickname" data-v-9d847660>
      L.Rain
    </section> <section class="info-desc" data-v-9d847660>真实、自由、宽容</section> <section class="info-contact" data-v-9d847660><section data-v-9d847660><span title="ChengDu City, China" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>ChengDu City, China</title><use xlink:href="#icon-location" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          ChengDu City, China
        </span></span></section> <section data-v-9d847660><span title="ChengDu YeeYun Technology" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>ChengDu YeeYun Technology</title><use xlink:href="#icon-organization" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          ChengDu YeeYun Technology
        </span></span></section> <section data-v-9d847660><a href="mailto:bxy2997@sina.com" title="bxy2997@sina.com" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>bxy2997@sina.com</title><use xlink:href="#icon-email" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          bxy2997@sina.com
        </span></a></section></section></div> <div class="info-card-footer" data-v-9d847660><section class="info-sns clearfix" data-v-9d847660><a href="https://github.com/baixiaoyu2997" target="_blank" class="sns-link" data-v-9d847660><span title="GitHub: L.Rain" class="sns-icon" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1.5em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>GitHub: L.Rain</title><use xlink:href="#icon-github" data-v-9d847660 data-v-9d847660></use></svg></span></a><a href="https://weibo.com/1504398495" target="_blank" class="sns-link" data-v-9d847660><span title="新浪微博: 白晓宇V" class="sns-icon" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1.5em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>新浪微博: 白晓宇V</title><use xlink:href="#icon-weibo" data-v-9d847660 data-v-9d847660></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-4dd605a1><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>文章目录</span> <div class="post-nav-toc"><ul><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-是什么">Docker 是什么？</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#为什么要用-docker">为什么要用 docker？</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-中的概念">docker 中的概念</a><ul><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#registry">Registry</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-镜像">Docker 镜像</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-容器">Docker 容器</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-数据卷">Docker 数据卷</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-网络">Docker 网络</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#host-宿主机">Host 宿主机</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#linux上安装docker">Linux上安装docker</a></li></ul></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-操作指令">docker 操作指令</a><ul><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#attach">attach</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#build">build</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#container">container</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#commit">commit</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#cp">cp</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#pull">pull</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#push">push</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#history">history</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#info">info</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#inspect">inspect</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#images">images</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#load">load</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#logs">logs</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#tag">tag</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#top">top</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#run">run</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#ps">ps</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#exec">exec</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#search">search</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#save">save</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#start">start</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#stop">stop</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#volume">volume</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#kill">kill</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#rm">rm</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#rename">rename</a></li></ul></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-数据卷-2">Docker 数据卷</a><ul><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#匿名挂载">匿名挂载</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#具名挂载">具名挂载</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#查看挂载目录位置">查看挂载目录位置</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#读写权限">读写权限</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#数据卷容器">数据卷容器</a></li></ul></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#dockerfile">Dockerfile</a><ul><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#add">ADD</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#copy">COPY</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#cmd">CMD</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#env">ENV</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#entrypoint">ENTRYPOINT</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#expose">EXPOSE</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#from">FROM</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#maintainer">MAINTAINER</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#volume-2">VOLUME</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#workdir">WORKDIR</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#onbuild">ONBUILD</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#run-2">RUN</a></li></ul></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-compose">docker-compose</a><ul><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#介绍">介绍</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#安装">安装</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#容器编排">容器编排</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#流程">流程</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#指令">指令</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-compose-yml">docker-compose.yml</a></li></ul></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker发布镜像">docker发布镜像</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#调试">调试</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-部署流程">docker 部署流程</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker网络">docker网络</a><ul><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker0">docker0</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#link-不建议使用">--link （不建议使用）</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#自定义网络">自定义网络</a></li></ul></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#linux">Linux</a><ul><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#启动docker">启动docker</a></li></ul></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#最佳实践">最佳实践</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#问题">问题</a><ul><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker-build与yarn一起使用">docker build与yarn一起使用</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker为什么-d后台启动容器后-容器停止了">docker为什么-d后台启动容器后，容器停止了？</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#docker镜像挂载外部文件">docker镜像挂载外部文件？</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#删除所有none标签镜像">删除所有none标签镜像</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#删除所有-images">删除所有 images</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#删除所有镜像和容器">删除所有镜像和容器</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#删除名称中包含某个字符串的镜像">删除名称中包含某个字符串的镜像</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#mac无法ping通容器中的ip">mac无法ping通容器中的ip？</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#配置-p后公网ip无法访问">配置-p后公网ip无法访问？</a></li></ul></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#学习资源">学习资源</a></li><li><a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#引用">引用</a></li></ul></div></div> <div class="post-nav-comments"><svg class="icon"><title>comment</title><use xlink:href="#icon-comment"></use></svg> <a href="/posts/2020/08/12/docker%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html#post-comments">
      评论
    </a></div></div></aside></div> <footer class="footer" data-v-1375e54c><p class="footer-sns-links" data-v-1375e54c><a href="https://github.com/baixiaoyu2997" target="_blank" class="sns-link" data-v-1375e54c><span title="GitHub: L.Rain" class="sns-icon" data-v-1375e54c data-v-1375e54c><svg class="icon" style="font-size:25px;" data-v-1375e54c data-v-1375e54c><title data-v-1375e54c data-v-1375e54c>GitHub: L.Rain</title><use xlink:href="#icon-github" data-v-1375e54c data-v-1375e54c></use></svg></span></a><a href="https://weibo.com/1504398495" target="_blank" class="sns-link" data-v-1375e54c><span title="新浪微博: 白晓宇V" class="sns-icon" data-v-1375e54c data-v-1375e54c><svg class="icon" style="font-size:25px;" data-v-1375e54c data-v-1375e54c><title data-v-1375e54c data-v-1375e54c>新浪微博: 白晓宇V</title><use xlink:href="#icon-weibo" data-v-1375e54c data-v-1375e54c></use></svg></span></a></p> <p class="footer-text" data-v-1375e54c><span data-v-1375e54c>Powered by </span> <a href="https://github.com/vuejs/vuepress" target="_blank" data-v-1375e54c>
      VuePress
    </a> <span data-v-1375e54c> | </span> <a href="https://github.com/meteorlxy/vuepress-theme-meteorlxy" target="_blank" data-v-1375e54c>
        meteorlxy
      </a></p> <!----></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.f3f948e5.js" defer></script><script src="/assets/js/7.8545d9f8.js" defer></script><script src="/assets/js/19.3c94f51e.js" defer></script>
  </body>
</html>
